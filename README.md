# AXP192 Power Management IC Driver (axp192-dd)

[![Crates.io](https://img.shields.io/crates/v/axp192-dd.svg)](https://crates.io/crates/axp192-dd)
[![Docs.rs](https://docs.rs/axp192-dd/badge.svg)](https://docs.rs/axp192-dd)
[![License: MIT OR Apache-2.0](https://img.shields.io/badge/License-MIT%20OR%20Apache--2.0-blue.svg)](https://opensource.org/licenses)
[![Build Status](https://img.shields.io/github/actions/workflow/status/okhsunrog/axp192-dd/rust_ci.yml?logo=github)](https://github.com/okhsunrog/axp192-dd/actions/workflows/rust_ci.yml)

This crate provides a no_std driver for the AXP192 power management IC, commonly used in M5Stack devices and other embedded systems. The project aims to support the full functionality of the AXP192 PMIC, leveraging the device-driver crate with a declarative YAML manifest (device.yaml) for a robust, type-safe register map definition. The low-level API covers 100% of the AXP192's registers, with device.yaml providing a comprehensive and accurate description of all registers and their fields. While the low-level API is complete, some high-level convenience methods for easier access may still be added in the future.

## Overview

The `axp192-dd` driver offers:

- **Declarative Configuration:** The AXP192 register map is defined in [`device.yaml`](device.yaml), enabling `device-driver` to generate a type-safe, low-level register access API. This approach enhances maintainability and extensibility.
- **Unified Async/Blocking API:** Uses the [`bisync`](https://github.com/JM4ier/bisync) crate to provide both asynchronous (`Axp192Async`) and blocking (`Axp192`) drivers from the same codebase, with no feature flags required.
- **High-Level and Low-Level APIs:**
  - High-level methods simplify tasks like setting DC-DC/LDO voltages, reading ADC voltages.
  - Low-level API (via the `ll` field of the `Axp192`/`Axp192Async` struct) offers direct, type-safe access to all registers defined in `device.yaml` via raw values or enums.
- **Peripheral Control:** Manages DC-DCs, LDOs, GPIOs, ADC conversions, interrupts, and power settings.
- **`no_std` and `no-alloc`:** Optimized for bare-metal and RTOS environments.
- **Optional Logging:** Supports `defmt` and the `log` facade for debugging.

## ⚠️ Warning! ⚠️

**Caution!** The AXP192 controls power to the microcontroller and critical components. Incorrect configuration may cause malfunctions, data loss, or hardware damage.

- **Always consult the official AXP192 datasheet** (see [Datasheet](#datasheet)) before modifying power settings.
- Verify voltage and current limits for your device and components.
- Exercise caution when adjusting output voltages or charging parameters.
- The authors are not liable for damage caused by misuse.

## Features

- **Declarative Register Map:** Defined in `device.yaml`.
- **Unified Async/Blocking API:** Both async and blocking drivers are always available; no feature flags required.
- **Type-Safe Register Access:** Generated by `device-driver`.
- **Comprehensive Control:** (See `device.yaml` for details)
  - DC-DC and LDO voltage/enable.
  - Battery charging and status.
  - ADC readings (voltages, currents, temperature).
  - GPIO configuration.
  - Interrupt management.
  - Power key (PEK) parameters.
- **`no_std` and `no-alloc`**.
- **Optional Logging:** Supports `defmt` and `log` facade.

## Getting Started

1. **Add `axp192-dd` to `Cargo.toml`:**

   ```toml
   [dependencies]
   axp192-dd = "0.1.0"
   # For blocking usage (Axp192):
   embedded-hal = "1.0.0"
   # For async usage (Axp192Async):
   embedded-hal-async = "1.0.0"
   ```

   > **Note:** Add the relevant `embedded-hal` crate for your use case, no need for both  
   > - Use `embedded-hal` for blocking drivers (`Axp192`)  
   > - Use `embedded-hal-async` for async drivers (`Axp192Async`)

2. **Instantiate the driver with your I2C bus:**

   - **Blocking:**
     ```rust
     use axp192_dd::{Axp192, LdoId};
     use embedded_hal::i2c::I2c;

     let i2c_bus_impl = /* your I2C bus */;
     let mut axp = Axp192::new(i2c_bus_impl);
     axp.set_ldo_voltage_mv(LdoId::Ldo2, 3300)?;
     ```

   - **Async:**
     ```rust
     use axp192_dd::{Axp192Async, LdoId};
     use embedded_hal_async::i2c::I2c;

     let i2c_bus_impl = /* your I2C bus */;
     let mut axp = Axp192Async::new(i2c_bus_impl);
     axp.set_ldo_voltage_mv(LdoId::Ldo2, 3300).await?;
     ```

## Low-Level API Usage

The driver provides direct access to all AXP192 registers through the low-level API via `axp.ll`. This API is automatically generated from [`device.yaml`](device.yaml) and provides type-safe access to all register fields.

### Reading Registers

Use `.read()` to read a register and access its fields:

```rust
// Read power status
let status = axp.ll.power_status().read()?;
let acin_present = status.acin_present();
let vbus_present = status.vbus_present();

// Read battery gauge data
let gauge = axp.ll.battery_gauge_data().read()?;
let percentage = gauge.percentage();

// Read chip ID and access individual fields
let chip_id = axp.ll.chip_id().read()?;
let id_value = chip_id.chip_id();
```

### Writing Registers

Use `.write()` with a closure to modify register fields. The closure receives a mutable reference to the register structure:

```rust
// Enable ADC channels
axp.ll.adc_enable_1().write(|w| {
    w.set_battery_current_adc_enable(true);
    w.set_vbus_voltage_adc_enable(true);
    w.set_vbus_current_adc_enable(true);
})?;

// Configure GPIO0 control
axp.ll.gpio_0_control().write(|w| {
    w.set_function_select(Gpio0FunctionSelect::LowNoiseLdoOutput);
})?;

// Configure charge current
axp.ll.charge_control_1().write(|w| {
    w.set_charge_current(ChargeCurrentValue::Ma100);
})?;
```

### Modifying Registers

Use `.modify()` to read-modify-write, preserving other fields:

```rust
// Enable specific power outputs without affecting others
// modify() reads the register, applies your changes, then writes it back
axp.ll.power_output_control().modify(|w| {
    w.set_dcdc_1_output_enable(true);
    w.set_ldo_2_output_enable(true);
    // Other fields remain unchanged
})?;
```

### Async Low-Level API

The low-level API has async versions for use with `Axp192Async`. Simply append `_async` to the method name:

```rust
// Async read
let status = axp.ll.power_status().read_async().await?;
let gauge = axp.ll.battery_gauge_data().read_async().await?;

// Async write
axp.ll.adc_enable_1().write_async(|w| {
    w.set_battery_current_adc_enable(true);
    w.set_vbus_voltage_adc_enable(true);
}).await?;

// Async modify
axp.ll.power_output_control().modify_async(|w| {
    w.set_dcdc_1_output_enable(true);
    w.set_ldo_2_output_enable(true);
}).await?;
```

### Field Naming Convention

Register and field names in the LL API follow snake_case and are derived from the names in [`device.yaml`](device.yaml):

- Register: `PowerOutputControl` → `power_output_control()`
- Field: `dcdc_1_output_enable` → `set_dcdc_1_output_enable()` / `dcdc_1_output_enable()`
- Register: `AdcEnable1` → `adc_enable_1()`
- Field: `battery_current_adc_enable` → `set_battery_current_adc_enable()` / `battery_current_adc_enable()`

### Finding Register/Field Names

1. **Check [`device.yaml`](device.yaml)** - All registers and fields are documented there
2. **Use IDE autocomplete** - Type `axp.ll.` to see all available registers
3. **Read a register** - Use `.read()` then autocomplete to see available field getters
4. **Write a register** - The closure parameter has autocomplete for all setters

## Examples

Examples for ESP32-C3 using `esp-hal` are included. Setup is required (see [esp-hal docs](https://esp-rs.github.io/book/installation/)). Both examples demonstrate high-level convenience methods and low-level register API usage.

- **Async Example:** [`examples/test_pmic_async.rs`](examples/test_pmic_async.rs)
  ```bash
  cargo run --release --example test_pmic_async --features defmt
  ```
- **Blocking Example:** [`examples/test_pmic_blocking.rs`](examples/test_pmic_blocking.rs)
  ```bash
  cargo run --release --example test_pmic_blocking --features defmt
  ```

## Register Map

The AXP192 register map is defined in [`device.yaml`](device.yaml), which `device-driver` uses to generate Rust code. This file specifies:

- Register names, addresses, and sizes.
- Field names, bit positions, and access modes (Read-Only, Read-Write, Write-1-Clear).
- Enumerations for field values (e.g., charging currents, voltage settings).
- Reset values and descriptions based on the datasheet.

## Supported Devices

The AXP192 is used in devices including:

- [M5Stack Core 2](https://docs.m5stack.com/en/core/core2) (and [Core 2 for AWS](https://docs.m5stack.com/en/core/core2_for_aws))
- [M5Stack Tough](https://docs.m5stack.com/en/core/tough)
- [M5StickC](https://docs.m5stack.com/en/core/m5stickc)
- [M5StickC PLUS](https://docs.m5stack.com/en/core/m5stickc_plus)

## Datasheet

- [AXP192 Datasheet v1.1 (English Draft)](https://github.com/m5stack/M5-Schematic/blob/master/Core/AXP192%20Datasheet_v1.1_en_draft_2211.pdf)

## Feature Flags

- **`default = []`**: No default features; async and blocking drivers are always available.
- **`std`**: Enables `std` features for `thiserror`.
- **`log`**: Enables `log` facade logging. Requires `log = { version = "0.4", optional = true }`.
- **`defmt`**: Enables `defmt` logging. Requires `defmt = { version = "1.0", optional = true }`.

### Contributions are welcome! While the register map in device.yaml is complete, you can contribute by:

- Adding high-level convenience methods to simplify common operations (e.g., battery management, interrupt handling).
- Enhancing documentation with additional examples or clarifications.
- Reporting issues or suggesting improvements.
- Suggest code refactoring.

Please submit issues, fork the repository, and create pull requests.

## License

This project is dual-licensed under the [MIT License](LICENSE-MIT) or [Apache License 2.0](LICENSE-APACHE), at your option.
