#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use core::prelude::rust_2024::*;
#[macro_use]
extern crate core;
#[macro_use]
pub(crate) mod fmt {
    #![macro_use]
    #![allow(unused)]
    use core::fmt::{Debug, Display, LowerHex};
    pub struct NoneError;
    #[automatically_derived]
    impl ::core::fmt::Debug for NoneError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "NoneError")
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for NoneError {}
    #[automatically_derived]
    impl ::core::clone::Clone for NoneError {
        #[inline]
        fn clone(&self) -> NoneError {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for NoneError {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NoneError {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NoneError {
        #[inline]
        fn eq(&self, other: &NoneError) -> bool {
            true
        }
    }
    pub trait Try {
        type Ok;
        type Error;
        fn into_result(self) -> Result<Self::Ok, Self::Error>;
    }
    impl<T> Try for Option<T> {
        type Ok = T;
        type Error = NoneError;
        #[inline]
        fn into_result(self) -> Result<T, NoneError> {
            self.ok_or(NoneError)
        }
    }
    impl<T, E> Try for Result<T, E> {
        type Ok = T;
        type Error = E;
        #[inline]
        fn into_result(self) -> Self {
            self
        }
    }
    pub(crate) struct Bytes<'a>(pub &'a [u8]);
    impl Debug for Bytes<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_fmt(format_args!("{0:#02x?}", self.0))
        }
    }
    impl Display for Bytes<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_fmt(format_args!("{0:#02x?}", self.0))
        }
    }
    impl LowerHex for Bytes<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_fmt(format_args!("{0:#02x?}", self.0))
        }
    }
}
use thiserror::Error;
pub enum AxpError<I2cErr> {
    #[error("I2C error")]
    I2c(I2cErr),
    #[error("Invalid voltage: {0}mV")]
    InvalidVoltage(u16),
    #[error("Invalid current: {0}mA")]
    InvalidCurrent(u16),
    #[error("Invalid GPIO param for pin {pin:?} mode {mode:?}")]
    InvalidGpioParameter { pin: GpioPin, mode: GpioMode },
    #[error("GPIO unavailable")]
    GpioFeatureUnavailable,
    #[error("Not implemented: {0}")]
    NotImplemented(&'static str),
}
#[automatically_derived]
impl<I2cErr: ::core::fmt::Debug> ::core::fmt::Debug for AxpError<I2cErr> {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match self {
            AxpError::I2c(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(f, "I2c", &__self_0)
            }
            AxpError::InvalidVoltage(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InvalidVoltage",
                    &__self_0,
                )
            }
            AxpError::InvalidCurrent(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "InvalidCurrent",
                    &__self_0,
                )
            }
            AxpError::InvalidGpioParameter { pin: __self_0, mode: __self_1 } => {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "InvalidGpioParameter",
                    "pin",
                    __self_0,
                    "mode",
                    &__self_1,
                )
            }
            AxpError::GpioFeatureUnavailable => {
                ::core::fmt::Formatter::write_str(f, "GpioFeatureUnavailable")
            }
            AxpError::NotImplemented(__self_0) => {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "NotImplemented",
                    &__self_0,
                )
            }
        }
    }
}
#[allow(unused_qualifications)]
#[automatically_derived]
impl<I2cErr> ::thiserror::__private::Error for AxpError<I2cErr>
where
    Self: ::core::fmt::Debug + ::core::fmt::Display,
{}
#[allow(unused_qualifications)]
#[automatically_derived]
impl<I2cErr> ::core::fmt::Display for AxpError<I2cErr> {
    fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use ::thiserror::__private::AsDisplay as _;
        #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
        match self {
            AxpError::I2c(_0) => __formatter.write_str("I2C error"),
            AxpError::InvalidVoltage(_0) => {
                match (_0.as_display(),) {
                    (__display0,) => {
                        __formatter
                            .write_fmt(
                                format_args!("Invalid voltage: {0}mV", __display0),
                            )
                    }
                }
            }
            AxpError::InvalidCurrent(_0) => {
                match (_0.as_display(),) {
                    (__display0,) => {
                        __formatter
                            .write_fmt(
                                format_args!("Invalid current: {0}mA", __display0),
                            )
                    }
                }
            }
            AxpError::InvalidGpioParameter { pin, mode } => {
                match (pin, mode) {
                    (__field_pin, __field_mode) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "Invalid GPIO param for pin {0:?} mode {1:?}",
                                    __field_pin,
                                    __field_mode,
                                ),
                            )
                    }
                }
            }
            AxpError::GpioFeatureUnavailable {} => {
                __formatter.write_str("GPIO unavailable")
            }
            AxpError::NotImplemented(_0) => {
                match (_0.as_display(),) {
                    (__display0,) => {
                        __formatter
                            .write_fmt(format_args!("Not implemented: {0}", __display0))
                    }
                }
            }
        }
    }
}
pub enum DcId {
    Dcdc1,
    Dcdc3,
}
#[automatically_derived]
impl ::core::fmt::Debug for DcId {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                DcId::Dcdc1 => "Dcdc1",
                DcId::Dcdc3 => "Dcdc3",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for DcId {
    #[inline]
    fn clone(&self) -> DcId {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for DcId {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for DcId {}
#[automatically_derived]
impl ::core::cmp::PartialEq for DcId {
    #[inline]
    fn eq(&self, other: &DcId) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for DcId {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
pub enum LdoId {
    Ldo2,
    Ldo3,
}
#[automatically_derived]
impl ::core::fmt::Debug for LdoId {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                LdoId::Ldo2 => "Ldo2",
                LdoId::Ldo3 => "Ldo3",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for LdoId {
    #[inline]
    fn clone(&self) -> LdoId {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for LdoId {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for LdoId {}
#[automatically_derived]
impl ::core::cmp::PartialEq for LdoId {
    #[inline]
    fn eq(&self, other: &LdoId) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for LdoId {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
pub enum GpioPin {
    Gpio0,
    Gpio1,
    Gpio2,
}
#[automatically_derived]
impl ::core::fmt::Debug for GpioPin {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                GpioPin::Gpio0 => "Gpio0",
                GpioPin::Gpio1 => "Gpio1",
                GpioPin::Gpio2 => "Gpio2",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for GpioPin {
    #[inline]
    fn clone(&self) -> GpioPin {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for GpioPin {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for GpioPin {}
#[automatically_derived]
impl ::core::cmp::PartialEq for GpioPin {
    #[inline]
    fn eq(&self, other: &GpioPin) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for GpioPin {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[repr(u8)]
pub enum GpioMode {
    NmosOpenDrainOutput = 0,
    UniversalInput = 1,
    SpecialOutput010 = 2,
    AdcInput = 4,
    LowOutput = 5,
    Floating = 6,
}
#[automatically_derived]
impl ::core::fmt::Debug for GpioMode {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                GpioMode::NmosOpenDrainOutput => "NmosOpenDrainOutput",
                GpioMode::UniversalInput => "UniversalInput",
                GpioMode::SpecialOutput010 => "SpecialOutput010",
                GpioMode::AdcInput => "AdcInput",
                GpioMode::LowOutput => "LowOutput",
                GpioMode::Floating => "Floating",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for GpioMode {
    #[inline]
    fn clone(&self) -> GpioMode {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for GpioMode {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for GpioMode {}
#[automatically_derived]
impl ::core::cmp::PartialEq for GpioMode {
    #[inline]
    fn eq(&self, other: &GpioMode) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for GpioMode {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[repr(u8)]
pub enum ChargeTargetVoltage {
    V4_10 = 0,
    V4_15 = 1,
    V4_20 = 2,
    V4_36 = 3,
}
#[automatically_derived]
impl ::core::fmt::Debug for ChargeTargetVoltage {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                ChargeTargetVoltage::V4_10 => "V4_10",
                ChargeTargetVoltage::V4_15 => "V4_15",
                ChargeTargetVoltage::V4_20 => "V4_20",
                ChargeTargetVoltage::V4_36 => "V4_36",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for ChargeTargetVoltage {
    #[inline]
    fn clone(&self) -> ChargeTargetVoltage {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for ChargeTargetVoltage {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for ChargeTargetVoltage {}
#[automatically_derived]
impl ::core::cmp::PartialEq for ChargeTargetVoltage {
    #[inline]
    fn eq(&self, other: &ChargeTargetVoltage) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for ChargeTargetVoltage {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[repr(u8)]
pub enum PekBootTime {
    S128ms = 0,
    S512ms = 1,
    S1 = 2,
    S2 = 3,
}
#[automatically_derived]
impl ::core::fmt::Debug for PekBootTime {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                PekBootTime::S128ms => "S128ms",
                PekBootTime::S512ms => "S512ms",
                PekBootTime::S1 => "S1",
                PekBootTime::S2 => "S2",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for PekBootTime {
    #[inline]
    fn clone(&self) -> PekBootTime {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for PekBootTime {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for PekBootTime {}
#[automatically_derived]
impl ::core::cmp::PartialEq for PekBootTime {
    #[inline]
    fn eq(&self, other: &PekBootTime) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for PekBootTime {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[repr(u8)]
pub enum PekLongPressTime {
    Ms1000 = 0,
    Ms1500 = 1,
    Ms2000 = 2,
    Ms2500 = 3,
}
#[automatically_derived]
impl ::core::fmt::Debug for PekLongPressTime {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                PekLongPressTime::Ms1000 => "Ms1000",
                PekLongPressTime::Ms1500 => "Ms1500",
                PekLongPressTime::Ms2000 => "Ms2000",
                PekLongPressTime::Ms2500 => "Ms2500",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for PekLongPressTime {
    #[inline]
    fn clone(&self) -> PekLongPressTime {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for PekLongPressTime {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for PekLongPressTime {}
#[automatically_derived]
impl ::core::cmp::PartialEq for PekLongPressTime {
    #[inline]
    fn eq(&self, other: &PekLongPressTime) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for PekLongPressTime {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[repr(u8)]
pub enum PekShutdownDuration {
    S4 = 0,
    S6 = 1,
    S8 = 2,
    S10 = 3,
}
#[automatically_derived]
impl ::core::fmt::Debug for PekShutdownDuration {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::write_str(
            f,
            match self {
                PekShutdownDuration::S4 => "S4",
                PekShutdownDuration::S6 => "S6",
                PekShutdownDuration::S8 => "S8",
                PekShutdownDuration::S10 => "S10",
            },
        )
    }
}
#[automatically_derived]
impl ::core::clone::Clone for PekShutdownDuration {
    #[inline]
    fn clone(&self) -> PekShutdownDuration {
        *self
    }
}
#[automatically_derived]
impl ::core::marker::Copy for PekShutdownDuration {}
#[automatically_derived]
impl ::core::marker::StructuralPartialEq for PekShutdownDuration {}
#[automatically_derived]
impl ::core::cmp::PartialEq for PekShutdownDuration {
    #[inline]
    fn eq(&self, other: &PekShutdownDuration) -> bool {
        let __self_discr = ::core::intrinsics::discriminant_value(self);
        let __arg1_discr = ::core::intrinsics::discriminant_value(other);
        __self_discr == __arg1_discr
    }
}
#[automatically_derived]
impl ::core::cmp::Eq for PekShutdownDuration {
    #[inline]
    #[doc(hidden)]
    #[coverage(off)]
    fn assert_receiver_is_total_eq(&self) -> () {}
}
#[path = "."]
pub mod asynchronous {
    #[doc(hidden)]
    pub use bisync::asynchronous::*;
    mod driver_core {
        use super::*;
        use crate::{
            AxpError, DcId, GpioMode, GpioPin, LdoId, PekBootTime, PekLongPressTime,
            PekShutdownDuration,
        };
        ///Root block of the Device driver
        pub struct Device<I> {
            pub(crate) interface: I,
            #[doc(hidden)]
            base_address: u8,
        }
        #[automatically_derived]
        impl<I: ::core::fmt::Debug> ::core::fmt::Debug for Device<I> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Device",
                    "interface",
                    &self.interface,
                    "base_address",
                    &&self.base_address,
                )
            }
        }
        impl<I> Device<I> {
            /// Create a new instance of the block based on device interface
            pub const fn new(interface: I) -> Self {
                Self { interface, base_address: 0 }
            }
            /// A reference to the interface used to communicate with the device
            pub(crate) fn interface(&mut self) -> &mut I {
                &mut self.interface
            }
            /// Read all readable register values in this block from the device.
            /// The callback is called for each of them.
            /// Any registers in child blocks are not included.
            ///
            /// The callback has three arguments:
            ///
            /// - The address of the register
            /// - The name of the register (with index for repeated registers)
            /// - The read value from the register
            ///
            /// This is useful for e.g. debug printing all values.
            /// The given [field_sets::FieldSetValue] has a Debug and Format implementation that forwards to the concrete type
            /// the lies within so it can be printed without matching on it.
            pub fn read_all_registers(
                &mut self,
                mut callback: impl FnMut(u8, &'static str, field_sets::FieldSetValue),
            ) -> Result<(), I::Error>
            where
                I: ::device_driver::RegisterInterface<AddressType = u8>,
            {
                let reg = self.power_status().read()?;
                callback(0 + 0 * 0, "power_status", reg.into());
                let reg = self.charge_status().read()?;
                callback(1 + 0 * 0, "charge_status", reg.into());
                let reg = self.otg_vbus_status().read()?;
                callback(4 + 0 * 0, "otg_vbus_status", reg.into());
                let reg = self.data_buffer_0().read()?;
                callback(6 + 0 * 0, "data_buffer_0", reg.into());
                let reg = self.data_buffer_1().read()?;
                callback(7 + 0 * 0, "data_buffer_1", reg.into());
                let reg = self.data_buffer_2().read()?;
                callback(8 + 0 * 0, "data_buffer_2", reg.into());
                let reg = self.data_buffer_3().read()?;
                callback(9 + 0 * 0, "data_buffer_3", reg.into());
                let reg = self.data_buffer_4().read()?;
                callback(10 + 0 * 0, "data_buffer_4", reg.into());
                let reg = self.data_buffer_5().read()?;
                callback(11 + 0 * 0, "data_buffer_5", reg.into());
                let reg = self.exten_dcdc_2_control().read()?;
                callback(16 + 0 * 0, "exten_dcdc_2_control", reg.into());
                let reg = self.dcdc_13_ldo_23_control().read()?;
                callback(18 + 0 * 0, "dcdc_13_ldo_23_control", reg.into());
                let reg = self.dcdc_2_voltage().read()?;
                callback(35 + 0 * 0, "dcdc_2_voltage", reg.into());
                let reg = self.dcdc_2_slope().read()?;
                callback(37 + 0 * 0, "dcdc_2_slope", reg.into());
                let reg = self.dcdc_1_voltage().read()?;
                callback(38 + 0 * 0, "dcdc_1_voltage", reg.into());
                let reg = self.dcdc_3_voltage().read()?;
                callback(39 + 0 * 0, "dcdc_3_voltage", reg.into());
                let reg = self.ldo_23_voltage().read()?;
                callback(40 + 0 * 0, "ldo_23_voltage", reg.into());
                let reg = self.vbus_ipsout_channel().read()?;
                callback(48 + 0 * 0, "vbus_ipsout_channel", reg.into());
                let reg = self.shutdown_voltage().read()?;
                callback(49 + 0 * 0, "shutdown_voltage", reg.into());
                let reg = self.shutdown_battery_chgled_control().read()?;
                callback(50 + 0 * 0, "shutdown_battery_chgled_control", reg.into());
                let reg = self.charge_control_1().read()?;
                callback(51 + 0 * 0, "charge_control_1", reg.into());
                let reg = self.charge_control_2().read()?;
                callback(52 + 0 * 0, "charge_control_2", reg.into());
                let reg = self.battery_charge_control().read()?;
                callback(53 + 0 * 0, "battery_charge_control", reg.into());
                let reg = self.pek_settings().read()?;
                callback(54 + 0 * 0, "pek_settings", reg.into());
                let reg = self.dcdc_frequency().read()?;
                callback(55 + 0 * 0, "dcdc_frequency", reg.into());
                let reg = self.battery_charge_low_temp().read()?;
                callback(56 + 0 * 0, "battery_charge_low_temp", reg.into());
                let reg = self.battery_charge_high_temp().read()?;
                callback(57 + 0 * 0, "battery_charge_high_temp", reg.into());
                let reg = self.aps_low_power_1().read()?;
                callback(58 + 0 * 0, "aps_low_power_1", reg.into());
                let reg = self.aps_low_power_2().read()?;
                callback(59 + 0 * 0, "aps_low_power_2", reg.into());
                let reg = self.battery_discharge_low_temp().read()?;
                callback(60 + 0 * 0, "battery_discharge_low_temp", reg.into());
                let reg = self.battery_discharge_high_temp().read()?;
                callback(61 + 0 * 0, "battery_discharge_high_temp", reg.into());
                let reg = self.dcdc_mode().read()?;
                callback(128 + 0 * 0, "dcdc_mode", reg.into());
                let reg = self.adc_enable_1().read()?;
                callback(130 + 0 * 0, "adc_enable_1", reg.into());
                let reg = self.adc_enable_2().read()?;
                callback(131 + 0 * 0, "adc_enable_2", reg.into());
                let reg = self.adc_rate_ts_pin().read()?;
                callback(132 + 0 * 0, "adc_rate_ts_pin", reg.into());
                let reg = self.gpio_30_input_range().read()?;
                callback(133 + 0 * 0, "gpio_30_input_range", reg.into());
                let reg = self.gpio_0_adc_irq_rising().read()?;
                callback(134 + 0 * 0, "gpio_0_adc_irq_rising", reg.into());
                let reg = self.gpio_0_adc_irq_falling().read()?;
                callback(135 + 0 * 0, "gpio_0_adc_irq_falling", reg.into());
                let reg = self.timer_control().read()?;
                callback(138 + 0 * 0, "timer_control", reg.into());
                let reg = self.vbus_monitor().read()?;
                callback(139 + 0 * 0, "vbus_monitor", reg.into());
                let reg = self.temp_shutdown_control().read()?;
                callback(143 + 0 * 0, "temp_shutdown_control", reg.into());
                let reg = self.gpio_0_control().read()?;
                callback(144 + 0 * 0, "gpio_0_control", reg.into());
                let reg = self.gpio_0_ldoio_0_voltage().read()?;
                callback(145 + 0 * 0, "gpio_0_ldoio_0_voltage", reg.into());
                let reg = self.gpio_1_control().read()?;
                callback(146 + 0 * 0, "gpio_1_control", reg.into());
                let reg = self.gpio_2_control().read()?;
                callback(147 + 0 * 0, "gpio_2_control", reg.into());
                let reg = self.gpio_20_signal_status().read()?;
                callback(148 + 0 * 0, "gpio_20_signal_status", reg.into());
                let reg = self.gpio_43_function_control().read()?;
                callback(149 + 0 * 0, "gpio_43_function_control", reg.into());
                let reg = self.gpio_43_signal_status().read()?;
                callback(150 + 0 * 0, "gpio_43_signal_status", reg.into());
                let reg = self.gpio_20_pulldown_control().read()?;
                callback(151 + 0 * 0, "gpio_20_pulldown_control", reg.into());
                let reg = self.pwm_1_frequency().read()?;
                callback(152 + 0 * 0, "pwm_1_frequency", reg.into());
                let reg = self.pwm_1_duty_cycle_1().read()?;
                callback(153 + 0 * 0, "pwm_1_duty_cycle_1", reg.into());
                let reg = self.pwm_1_duty_cycle_2().read()?;
                callback(154 + 0 * 0, "pwm_1_duty_cycle_2", reg.into());
                let reg = self.pwm_2_frequency().read()?;
                callback(155 + 0 * 0, "pwm_2_frequency", reg.into());
                let reg = self.pwm_2_duty_cycle_1().read()?;
                callback(156 + 0 * 0, "pwm_2_duty_cycle_1", reg.into());
                let reg = self.pwm_2_duty_cycle_2().read()?;
                callback(157 + 0 * 0, "pwm_2_duty_cycle_2", reg.into());
                let reg = self.n_rsto_gpio_5_control().read()?;
                callback(158 + 0 * 0, "n_rsto_gpio_5_control", reg.into());
                let reg = self.enable_control_1().read()?;
                callback(64 + 0 * 0, "enable_control_1", reg.into());
                let reg = self.enable_control_2().read()?;
                callback(65 + 0 * 0, "enable_control_2", reg.into());
                let reg = self.enable_control_3().read()?;
                callback(66 + 0 * 0, "enable_control_3", reg.into());
                let reg = self.enable_control_4().read()?;
                callback(67 + 0 * 0, "enable_control_4", reg.into());
                let reg = self.enable_control_5().read()?;
                callback(74 + 0 * 0, "enable_control_5", reg.into());
                let reg = self.irq_status_1().read()?;
                callback(68 + 0 * 0, "irq_status_1", reg.into());
                let reg = self.irq_status_2().read()?;
                callback(69 + 0 * 0, "irq_status_2", reg.into());
                let reg = self.irq_status_3().read()?;
                callback(70 + 0 * 0, "irq_status_3", reg.into());
                let reg = self.irq_status_4().read()?;
                callback(71 + 0 * 0, "irq_status_4", reg.into());
                let reg = self.irq_status_5().read()?;
                callback(77 + 0 * 0, "irq_status_5", reg.into());
                let reg = self.acin_voltage_adc().read()?;
                callback(86 + 0 * 0, "acin_voltage_adc", reg.into());
                let reg = self.acin_current_adc().read()?;
                callback(88 + 0 * 0, "acin_current_adc", reg.into());
                let reg = self.vbus_voltage_adc().read()?;
                callback(90 + 0 * 0, "vbus_voltage_adc", reg.into());
                let reg = self.vbus_current_adc().read()?;
                callback(92 + 0 * 0, "vbus_current_adc", reg.into());
                let reg = self.internal_temperature_adc().read()?;
                callback(94 + 0 * 0, "internal_temperature_adc", reg.into());
                let reg = self.ts_input_adc().read()?;
                callback(98 + 0 * 0, "ts_input_adc", reg.into());
                let reg = self.gpio_0_voltage_adc().read()?;
                callback(100 + 0 * 0, "gpio_0_voltage_adc", reg.into());
                let reg = self.gpio_1_voltage_adc().read()?;
                callback(102 + 0 * 0, "gpio_1_voltage_adc", reg.into());
                let reg = self.gpio_2_voltage_adc().read()?;
                callback(104 + 0 * 0, "gpio_2_voltage_adc", reg.into());
                let reg = self.gpio_3_voltage_adc().read()?;
                callback(106 + 0 * 0, "gpio_3_voltage_adc", reg.into());
                let reg = self.battery_power_adc().read()?;
                callback(112 + 0 * 0, "battery_power_adc", reg.into());
                let reg = self.battery_voltage_adc().read()?;
                callback(120 + 0 * 0, "battery_voltage_adc", reg.into());
                let reg = self.charge_current_adc().read()?;
                callback(122 + 0 * 0, "charge_current_adc", reg.into());
                let reg = self.discharge_current_adc().read()?;
                callback(124 + 0 * 0, "discharge_current_adc", reg.into());
                let reg = self.aps_voltage_adc().read()?;
                callback(126 + 0 * 0, "aps_voltage_adc", reg.into());
                let reg = self.charge_coulomb_counter().read()?;
                callback(176 + 0 * 0, "charge_coulomb_counter", reg.into());
                let reg = self.discharge_coulomb_counter().read()?;
                callback(180 + 0 * 0, "discharge_coulomb_counter", reg.into());
                let reg = self.coulomb_counter_control().read()?;
                callback(184 + 0 * 0, "coulomb_counter_control", reg.into());
                Ok(())
            }
            /// Read all readable register values in this block from the device.
            /// The callback is called for each of them.
            /// Any registers in child blocks are not included.
            ///
            /// The callback has three arguments:
            ///
            /// - The address of the register
            /// - The name of the register (with index for repeated registers)
            /// - The read value from the register
            ///
            /// This is useful for e.g. debug printing all values.
            /// The given [field_sets::FieldSetValue] has a Debug and Format implementation that forwards to the concrete type
            /// the lies within so it can be printed without matching on it.
            pub async fn read_all_registers_async(
                &mut self,
                mut callback: impl FnMut(u8, &'static str, field_sets::FieldSetValue),
            ) -> Result<(), I::Error>
            where
                I: ::device_driver::AsyncRegisterInterface<AddressType = u8>,
            {
                let reg = self.power_status().read_async().await?;
                callback(0 + 0 * 0, "power_status", reg.into());
                let reg = self.charge_status().read_async().await?;
                callback(1 + 0 * 0, "charge_status", reg.into());
                let reg = self.otg_vbus_status().read_async().await?;
                callback(4 + 0 * 0, "otg_vbus_status", reg.into());
                let reg = self.data_buffer_0().read_async().await?;
                callback(6 + 0 * 0, "data_buffer_0", reg.into());
                let reg = self.data_buffer_1().read_async().await?;
                callback(7 + 0 * 0, "data_buffer_1", reg.into());
                let reg = self.data_buffer_2().read_async().await?;
                callback(8 + 0 * 0, "data_buffer_2", reg.into());
                let reg = self.data_buffer_3().read_async().await?;
                callback(9 + 0 * 0, "data_buffer_3", reg.into());
                let reg = self.data_buffer_4().read_async().await?;
                callback(10 + 0 * 0, "data_buffer_4", reg.into());
                let reg = self.data_buffer_5().read_async().await?;
                callback(11 + 0 * 0, "data_buffer_5", reg.into());
                let reg = self.exten_dcdc_2_control().read_async().await?;
                callback(16 + 0 * 0, "exten_dcdc_2_control", reg.into());
                let reg = self.dcdc_13_ldo_23_control().read_async().await?;
                callback(18 + 0 * 0, "dcdc_13_ldo_23_control", reg.into());
                let reg = self.dcdc_2_voltage().read_async().await?;
                callback(35 + 0 * 0, "dcdc_2_voltage", reg.into());
                let reg = self.dcdc_2_slope().read_async().await?;
                callback(37 + 0 * 0, "dcdc_2_slope", reg.into());
                let reg = self.dcdc_1_voltage().read_async().await?;
                callback(38 + 0 * 0, "dcdc_1_voltage", reg.into());
                let reg = self.dcdc_3_voltage().read_async().await?;
                callback(39 + 0 * 0, "dcdc_3_voltage", reg.into());
                let reg = self.ldo_23_voltage().read_async().await?;
                callback(40 + 0 * 0, "ldo_23_voltage", reg.into());
                let reg = self.vbus_ipsout_channel().read_async().await?;
                callback(48 + 0 * 0, "vbus_ipsout_channel", reg.into());
                let reg = self.shutdown_voltage().read_async().await?;
                callback(49 + 0 * 0, "shutdown_voltage", reg.into());
                let reg = self.shutdown_battery_chgled_control().read_async().await?;
                callback(50 + 0 * 0, "shutdown_battery_chgled_control", reg.into());
                let reg = self.charge_control_1().read_async().await?;
                callback(51 + 0 * 0, "charge_control_1", reg.into());
                let reg = self.charge_control_2().read_async().await?;
                callback(52 + 0 * 0, "charge_control_2", reg.into());
                let reg = self.battery_charge_control().read_async().await?;
                callback(53 + 0 * 0, "battery_charge_control", reg.into());
                let reg = self.pek_settings().read_async().await?;
                callback(54 + 0 * 0, "pek_settings", reg.into());
                let reg = self.dcdc_frequency().read_async().await?;
                callback(55 + 0 * 0, "dcdc_frequency", reg.into());
                let reg = self.battery_charge_low_temp().read_async().await?;
                callback(56 + 0 * 0, "battery_charge_low_temp", reg.into());
                let reg = self.battery_charge_high_temp().read_async().await?;
                callback(57 + 0 * 0, "battery_charge_high_temp", reg.into());
                let reg = self.aps_low_power_1().read_async().await?;
                callback(58 + 0 * 0, "aps_low_power_1", reg.into());
                let reg = self.aps_low_power_2().read_async().await?;
                callback(59 + 0 * 0, "aps_low_power_2", reg.into());
                let reg = self.battery_discharge_low_temp().read_async().await?;
                callback(60 + 0 * 0, "battery_discharge_low_temp", reg.into());
                let reg = self.battery_discharge_high_temp().read_async().await?;
                callback(61 + 0 * 0, "battery_discharge_high_temp", reg.into());
                let reg = self.dcdc_mode().read_async().await?;
                callback(128 + 0 * 0, "dcdc_mode", reg.into());
                let reg = self.adc_enable_1().read_async().await?;
                callback(130 + 0 * 0, "adc_enable_1", reg.into());
                let reg = self.adc_enable_2().read_async().await?;
                callback(131 + 0 * 0, "adc_enable_2", reg.into());
                let reg = self.adc_rate_ts_pin().read_async().await?;
                callback(132 + 0 * 0, "adc_rate_ts_pin", reg.into());
                let reg = self.gpio_30_input_range().read_async().await?;
                callback(133 + 0 * 0, "gpio_30_input_range", reg.into());
                let reg = self.gpio_0_adc_irq_rising().read_async().await?;
                callback(134 + 0 * 0, "gpio_0_adc_irq_rising", reg.into());
                let reg = self.gpio_0_adc_irq_falling().read_async().await?;
                callback(135 + 0 * 0, "gpio_0_adc_irq_falling", reg.into());
                let reg = self.timer_control().read_async().await?;
                callback(138 + 0 * 0, "timer_control", reg.into());
                let reg = self.vbus_monitor().read_async().await?;
                callback(139 + 0 * 0, "vbus_monitor", reg.into());
                let reg = self.temp_shutdown_control().read_async().await?;
                callback(143 + 0 * 0, "temp_shutdown_control", reg.into());
                let reg = self.gpio_0_control().read_async().await?;
                callback(144 + 0 * 0, "gpio_0_control", reg.into());
                let reg = self.gpio_0_ldoio_0_voltage().read_async().await?;
                callback(145 + 0 * 0, "gpio_0_ldoio_0_voltage", reg.into());
                let reg = self.gpio_1_control().read_async().await?;
                callback(146 + 0 * 0, "gpio_1_control", reg.into());
                let reg = self.gpio_2_control().read_async().await?;
                callback(147 + 0 * 0, "gpio_2_control", reg.into());
                let reg = self.gpio_20_signal_status().read_async().await?;
                callback(148 + 0 * 0, "gpio_20_signal_status", reg.into());
                let reg = self.gpio_43_function_control().read_async().await?;
                callback(149 + 0 * 0, "gpio_43_function_control", reg.into());
                let reg = self.gpio_43_signal_status().read_async().await?;
                callback(150 + 0 * 0, "gpio_43_signal_status", reg.into());
                let reg = self.gpio_20_pulldown_control().read_async().await?;
                callback(151 + 0 * 0, "gpio_20_pulldown_control", reg.into());
                let reg = self.pwm_1_frequency().read_async().await?;
                callback(152 + 0 * 0, "pwm_1_frequency", reg.into());
                let reg = self.pwm_1_duty_cycle_1().read_async().await?;
                callback(153 + 0 * 0, "pwm_1_duty_cycle_1", reg.into());
                let reg = self.pwm_1_duty_cycle_2().read_async().await?;
                callback(154 + 0 * 0, "pwm_1_duty_cycle_2", reg.into());
                let reg = self.pwm_2_frequency().read_async().await?;
                callback(155 + 0 * 0, "pwm_2_frequency", reg.into());
                let reg = self.pwm_2_duty_cycle_1().read_async().await?;
                callback(156 + 0 * 0, "pwm_2_duty_cycle_1", reg.into());
                let reg = self.pwm_2_duty_cycle_2().read_async().await?;
                callback(157 + 0 * 0, "pwm_2_duty_cycle_2", reg.into());
                let reg = self.n_rsto_gpio_5_control().read_async().await?;
                callback(158 + 0 * 0, "n_rsto_gpio_5_control", reg.into());
                let reg = self.enable_control_1().read_async().await?;
                callback(64 + 0 * 0, "enable_control_1", reg.into());
                let reg = self.enable_control_2().read_async().await?;
                callback(65 + 0 * 0, "enable_control_2", reg.into());
                let reg = self.enable_control_3().read_async().await?;
                callback(66 + 0 * 0, "enable_control_3", reg.into());
                let reg = self.enable_control_4().read_async().await?;
                callback(67 + 0 * 0, "enable_control_4", reg.into());
                let reg = self.enable_control_5().read_async().await?;
                callback(74 + 0 * 0, "enable_control_5", reg.into());
                let reg = self.irq_status_1().read_async().await?;
                callback(68 + 0 * 0, "irq_status_1", reg.into());
                let reg = self.irq_status_2().read_async().await?;
                callback(69 + 0 * 0, "irq_status_2", reg.into());
                let reg = self.irq_status_3().read_async().await?;
                callback(70 + 0 * 0, "irq_status_3", reg.into());
                let reg = self.irq_status_4().read_async().await?;
                callback(71 + 0 * 0, "irq_status_4", reg.into());
                let reg = self.irq_status_5().read_async().await?;
                callback(77 + 0 * 0, "irq_status_5", reg.into());
                let reg = self.acin_voltage_adc().read_async().await?;
                callback(86 + 0 * 0, "acin_voltage_adc", reg.into());
                let reg = self.acin_current_adc().read_async().await?;
                callback(88 + 0 * 0, "acin_current_adc", reg.into());
                let reg = self.vbus_voltage_adc().read_async().await?;
                callback(90 + 0 * 0, "vbus_voltage_adc", reg.into());
                let reg = self.vbus_current_adc().read_async().await?;
                callback(92 + 0 * 0, "vbus_current_adc", reg.into());
                let reg = self.internal_temperature_adc().read_async().await?;
                callback(94 + 0 * 0, "internal_temperature_adc", reg.into());
                let reg = self.ts_input_adc().read_async().await?;
                callback(98 + 0 * 0, "ts_input_adc", reg.into());
                let reg = self.gpio_0_voltage_adc().read_async().await?;
                callback(100 + 0 * 0, "gpio_0_voltage_adc", reg.into());
                let reg = self.gpio_1_voltage_adc().read_async().await?;
                callback(102 + 0 * 0, "gpio_1_voltage_adc", reg.into());
                let reg = self.gpio_2_voltage_adc().read_async().await?;
                callback(104 + 0 * 0, "gpio_2_voltage_adc", reg.into());
                let reg = self.gpio_3_voltage_adc().read_async().await?;
                callback(106 + 0 * 0, "gpio_3_voltage_adc", reg.into());
                let reg = self.battery_power_adc().read_async().await?;
                callback(112 + 0 * 0, "battery_power_adc", reg.into());
                let reg = self.battery_voltage_adc().read_async().await?;
                callback(120 + 0 * 0, "battery_voltage_adc", reg.into());
                let reg = self.charge_current_adc().read_async().await?;
                callback(122 + 0 * 0, "charge_current_adc", reg.into());
                let reg = self.discharge_current_adc().read_async().await?;
                callback(124 + 0 * 0, "discharge_current_adc", reg.into());
                let reg = self.aps_voltage_adc().read_async().await?;
                callback(126 + 0 * 0, "aps_voltage_adc", reg.into());
                let reg = self.charge_coulomb_counter().read_async().await?;
                callback(176 + 0 * 0, "charge_coulomb_counter", reg.into());
                let reg = self.discharge_coulomb_counter().read_async().await?;
                callback(180 + 0 * 0, "discharge_coulomb_counter", reg.into());
                let reg = self.coulomb_counter_control().read_async().await?;
                callback(184 + 0 * 0, "coulomb_counter_control", reg.into());
                Ok(())
            }
            ///Input power status.
            pub fn power_status(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::PowerStatus,
                ::device_driver::RO,
            > {
                let address = self.base_address + 0;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::PowerStatus,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::PowerStatus::new)
            }
            ///Charging and battery status.
            pub fn charge_status(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ChargeStatus,
                ::device_driver::RO,
            > {
                let address = self.base_address + 1;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ChargeStatus,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::ChargeStatus::new)
            }
            ///OTG VBUS status.
            pub fn otg_vbus_status(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::OtgVbusStatus,
                ::device_driver::RO,
            > {
                let address = self.base_address + 4;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::OtgVbusStatus,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::OtgVbusStatus::new)
            }
            ///Data Buffer 0
            pub fn data_buffer_0(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DataBuffer0,
                ::device_driver::RW,
            > {
                let address = self.base_address + 6;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DataBuffer0,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DataBuffer0::new)
            }
            ///Data Buffer 1
            pub fn data_buffer_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DataBuffer1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 7;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DataBuffer1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DataBuffer1::new)
            }
            ///Data Buffer 2
            pub fn data_buffer_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DataBuffer2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 8;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DataBuffer2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DataBuffer2::new)
            }
            ///Data Buffer 3
            pub fn data_buffer_3(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DataBuffer3,
                ::device_driver::RW,
            > {
                let address = self.base_address + 9;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DataBuffer3,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DataBuffer3::new)
            }
            ///Data Buffer 4
            pub fn data_buffer_4(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DataBuffer4,
                ::device_driver::RW,
            > {
                let address = self.base_address + 10;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DataBuffer4,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DataBuffer4::new)
            }
            ///Data Buffer 5
            pub fn data_buffer_5(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DataBuffer5,
                ::device_driver::RW,
            > {
                let address = self.base_address + 11;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DataBuffer5,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DataBuffer5::new)
            }
            ///EXTEN and DC-DC2 enable control.
            pub fn exten_dcdc_2_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ExtenDcdc2Control,
                ::device_driver::RW,
            > {
                let address = self.base_address + 16;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ExtenDcdc2Control,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::ExtenDcdc2Control::new,
                )
            }
            ///Power output control for DCDC1/3, LDO2/3. Note: DCDC2/EXTEN control also here.
            pub fn dcdc_13_ldo_23_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Dcdc13Ldo23Control,
                ::device_driver::RW,
            > {
                let address = self.base_address + 18;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Dcdc13Ldo23Control,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Dcdc13Ldo23Control::new,
                )
            }
            ///DC-DC2 output voltage setting (0.7-2.275V or 0.7-3.5V, 25mV/step - check datasheet for your variant).
            pub fn dcdc_2_voltage(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Dcdc2Voltage,
                ::device_driver::RW,
            > {
                let address = self.base_address + 35;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Dcdc2Voltage,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Dcdc2Voltage::new)
            }
            ///DC-DC2 VRC slope control.
            pub fn dcdc_2_slope(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Dcdc2Slope,
                ::device_driver::RW,
            > {
                let address = self.base_address + 37;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Dcdc2Slope,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Dcdc2Slope::new)
            }
            ///DC-DC1 output voltage setting (0.7-3.5V, 25mV/step).
            pub fn dcdc_1_voltage(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Dcdc1Voltage,
                ::device_driver::RW,
            > {
                let address = self.base_address + 38;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Dcdc1Voltage,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Dcdc1Voltage::new)
            }
            ///DC-DC3 output voltage setting (0.7-3.5V, 25mV/step).
            pub fn dcdc_3_voltage(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Dcdc3Voltage,
                ::device_driver::RW,
            > {
                let address = self.base_address + 39;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Dcdc3Voltage,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Dcdc3Voltage::new)
            }
            ///LDO2/LDO3 output voltage settings (1.8-3.3V, 100mV/step).
            pub fn ldo_23_voltage(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Ldo23Voltage,
                ::device_driver::RW,
            > {
                let address = self.base_address + 40;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Ldo23Voltage,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Ldo23Voltage::new)
            }
            ///VBUS-IPSOUT path control and VBUS current limit.
            pub fn vbus_ipsout_channel(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::VbusIpsoutChannel,
                ::device_driver::RW,
            > {
                let address = self.base_address + 48;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::VbusIpsoutChannel,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::VbusIpsoutChannel::new,
                )
            }
            ///Voff shutdown voltage and Pek function control.
            pub fn shutdown_voltage(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ShutdownVoltage,
                ::device_driver::RW,
            > {
                let address = self.base_address + 49;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ShutdownVoltage,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::ShutdownVoltage::new)
            }
            ///Shutdown behavior, CHGLED control.
            pub fn shutdown_battery_chgled_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ShutdownBatteryChgledControl,
                ::device_driver::RW,
            > {
                let address = self.base_address + 50;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ShutdownBatteryChgledControl,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::ShutdownBatteryChgledControl::new,
                )
            }
            ///Charging control 1: target voltage, current, end current.
            pub fn charge_control_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ChargeControl1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 51;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ChargeControl1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::ChargeControl1::new)
            }
            ///Charging control 2: pre-charge time, constant current timeout.
            pub fn charge_control_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ChargeControl2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 52;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ChargeControl2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::ChargeControl2::new)
            }
            ///Backup battery charging control and other battery features.
            pub fn battery_charge_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::BatteryChargeControl,
                ::device_driver::RW,
            > {
                let address = self.base_address + 53;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::BatteryChargeControl,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::BatteryChargeControl::new,
                )
            }
            ///PEK button settings: boot/shutdown times, power on/off behavior.
            pub fn pek_settings(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::PekSettings,
                ::device_driver::RW,
            > {
                let address = self.base_address + 54;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::PekSettings,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::PekSettings::new)
            }
            ///DCDC working frequency setting.
            pub fn dcdc_frequency(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DcdcFrequency,
                ::device_driver::RW,
            > {
                let address = self.base_address + 55;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DcdcFrequency,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DcdcFrequency::new)
            }
            ///Battery charge low temperature threshold.
            pub fn battery_charge_low_temp(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::BatteryChargeLowTemp,
                ::device_driver::RW,
            > {
                let address = self.base_address + 56;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::BatteryChargeLowTemp,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::BatteryChargeLowTemp::new,
                )
            }
            ///Battery charge high temperature threshold.
            pub fn battery_charge_high_temp(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::BatteryChargeHighTemp,
                ::device_driver::RW,
            > {
                let address = self.base_address + 57;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::BatteryChargeHighTemp,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::BatteryChargeHighTemp::new,
                )
            }
            ///APS low power level 1 setting.
            pub fn aps_low_power_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ApsLowPower1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 58;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ApsLowPower1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::ApsLowPower1::new)
            }
            ///APS low power level 2 setting.
            pub fn aps_low_power_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ApsLowPower2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 59;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ApsLowPower2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::ApsLowPower2::new)
            }
            ///Battery discharge low temperature threshold.
            pub fn battery_discharge_low_temp(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::BatteryDischargeLowTemp,
                ::device_driver::RW,
            > {
                let address = self.base_address + 60;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::BatteryDischargeLowTemp,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::BatteryDischargeLowTemp::new,
                )
            }
            ///Battery discharge high temperature threshold.
            pub fn battery_discharge_high_temp(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::BatteryDischargeHighTemp,
                ::device_driver::RW,
            > {
                let address = self.base_address + 61;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::BatteryDischargeHighTemp,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::BatteryDischargeHighTemp::new,
                )
            }
            ///DCDC working mode control (Auto/PWM).
            pub fn dcdc_mode(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DcdcMode,
                ::device_driver::RW,
            > {
                let address = self.base_address + 128;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DcdcMode,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::DcdcMode::new)
            }
            ///ADC enable control 1.
            pub fn adc_enable_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::AdcEnable1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 130;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::AdcEnable1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::AdcEnable1::new)
            }
            ///ADC enable control 2 (GPIO ADCs, internal temp).
            pub fn adc_enable_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::AdcEnable2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 131;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::AdcEnable2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::AdcEnable2::new)
            }
            ///ADC sample rate, TS pin control.
            pub fn adc_rate_ts_pin(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::AdcRateTsPin,
                ::device_driver::RW,
            > {
                let address = self.base_address + 132;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::AdcRateTsPin,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::AdcRateTsPin::new)
            }
            ///GPIO0-3 ADC input range.
            pub fn gpio_30_input_range(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio30InputRange,
                ::device_driver::RW,
            > {
                let address = self.base_address + 133;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio30InputRange,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio30InputRange::new,
                )
            }
            ///GPIO0 ADC IRQ rising edge threshold.
            pub fn gpio_0_adc_irq_rising(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio0AdcIrqRising,
                ::device_driver::RW,
            > {
                let address = self.base_address + 134;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio0AdcIrqRising,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio0AdcIrqRising::new,
                )
            }
            ///GPIO0 ADC IRQ falling edge threshold.
            pub fn gpio_0_adc_irq_falling(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio0AdcIrqFalling,
                ::device_driver::RW,
            > {
                let address = self.base_address + 135;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio0AdcIrqFalling,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio0AdcIrqFalling::new,
                )
            }
            ///Timer control.
            pub fn timer_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::TimerControl,
                ::device_driver::RW,
            > {
                let address = self.base_address + 138;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::TimerControl,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::TimerControl::new)
            }
            ///VBUS monitor, salkl aralk ayar.
            pub fn vbus_monitor(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::VbusMonitor,
                ::device_driver::RW,
            > {
                let address = self.base_address + 139;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::VbusMonitor,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::VbusMonitor::new)
            }
            ///Over temperature shutdown control.
            pub fn temp_shutdown_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::TempShutdownControl,
                ::device_driver::RW,
            > {
                let address = self.base_address + 143;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::TempShutdownControl,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::TempShutdownControl::new,
                )
            }
            ///
            pub fn gpio_0_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio0Control,
                ::device_driver::RW,
            > {
                let address = self.base_address + 144;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio0Control,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Gpio0Control::new)
            }
            ///GPIO0 LDO (LDOIO0) output voltage setting.
            pub fn gpio_0_ldoio_0_voltage(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio0Ldoio0Voltage,
                ::device_driver::RW,
            > {
                let address = self.base_address + 145;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio0Ldoio0Voltage,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio0Ldoio0Voltage::new,
                )
            }
            ///
            pub fn gpio_1_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio1Control,
                ::device_driver::RW,
            > {
                let address = self.base_address + 146;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio1Control,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Gpio1Control::new)
            }
            ///
            pub fn gpio_2_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio2Control,
                ::device_driver::RW,
            > {
                let address = self.base_address + 147;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio2Control,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Gpio2Control::new)
            }
            ///
            pub fn gpio_20_signal_status(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio20SignalStatus,
                ::device_driver::RW,
            > {
                let address = self.base_address + 148;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio20SignalStatus,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio20SignalStatus::new,
                )
            }
            ///GPIO3/4 function control.
            pub fn gpio_43_function_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio43FunctionControl,
                ::device_driver::RW,
            > {
                let address = self.base_address + 149;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio43FunctionControl,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio43FunctionControl::new,
                )
            }
            ///GPIO3/4 output level control and input status.
            pub fn gpio_43_signal_status(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio43SignalStatus,
                ::device_driver::RW,
            > {
                let address = self.base_address + 150;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio43SignalStatus,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio43SignalStatus::new,
                )
            }
            ///GPIO0-2 pulldown resistor control.
            pub fn gpio_20_pulldown_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio20PulldownControl,
                ::device_driver::RW,
            > {
                let address = self.base_address + 151;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio20PulldownControl,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::Gpio20PulldownControl::new,
                )
            }
            ///PWM1 frequency setting.
            pub fn pwm_1_frequency(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Pwm1Frequency,
                ::device_driver::RW,
            > {
                let address = self.base_address + 152;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Pwm1Frequency,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Pwm1Frequency::new)
            }
            ///PWM1 duty cycle MSBs.
            pub fn pwm_1_duty_cycle_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Pwm1DutyCycle1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 153;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Pwm1DutyCycle1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Pwm1DutyCycle1::new)
            }
            ///PWM1 duty cycle LSBs.
            pub fn pwm_1_duty_cycle_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Pwm1DutyCycle2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 154;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Pwm1DutyCycle2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Pwm1DutyCycle2::new)
            }
            ///PWM2 frequency setting.
            pub fn pwm_2_frequency(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Pwm2Frequency,
                ::device_driver::RW,
            > {
                let address = self.base_address + 155;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Pwm2Frequency,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Pwm2Frequency::new)
            }
            ///PWM2 duty cycle MSBs.
            pub fn pwm_2_duty_cycle_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Pwm2DutyCycle1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 156;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Pwm2DutyCycle1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Pwm2DutyCycle1::new)
            }
            ///PWM2 duty cycle LSBs.
            pub fn pwm_2_duty_cycle_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Pwm2DutyCycle2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 157;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Pwm2DutyCycle2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::Pwm2DutyCycle2::new)
            }
            ///N_RSTO (Reset Out) / GPIO5 control.
            pub fn n_rsto_gpio_5_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::NRstoGpio5Control,
                ::device_driver::RW,
            > {
                let address = self.base_address + 158;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::NRstoGpio5Control,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::NRstoGpio5Control::new,
                )
            }
            ///Interrupt Enable Control 1.
            pub fn enable_control_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::EnableControl1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 64;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::EnableControl1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::EnableControl1::new)
            }
            ///Interrupt Enable Control 2.
            pub fn enable_control_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::EnableControl2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 65;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::EnableControl2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::EnableControl2::new)
            }
            ///Interrupt Enable Control 3.
            pub fn enable_control_3(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::EnableControl3,
                ::device_driver::RW,
            > {
                let address = self.base_address + 66;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::EnableControl3,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::EnableControl3::new)
            }
            ///Interrupt Enable Control 4.
            pub fn enable_control_4(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::EnableControl4,
                ::device_driver::RW,
            > {
                let address = self.base_address + 67;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::EnableControl4,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::EnableControl4::new)
            }
            ///Interrupt Enable Control 5.
            pub fn enable_control_5(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::EnableControl5,
                ::device_driver::RW,
            > {
                let address = self.base_address + 74;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::EnableControl5,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::EnableControl5::new)
            }
            ///Interrupt Status 1 (Write 1 to clear).
            pub fn irq_status_1(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::IrqStatus1,
                ::device_driver::RW,
            > {
                let address = self.base_address + 68;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::IrqStatus1,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::IrqStatus1::new)
            }
            ///Interrupt Status 2.
            pub fn irq_status_2(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::IrqStatus2,
                ::device_driver::RW,
            > {
                let address = self.base_address + 69;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::IrqStatus2,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::IrqStatus2::new)
            }
            ///Interrupt Status 3.
            pub fn irq_status_3(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::IrqStatus3,
                ::device_driver::RW,
            > {
                let address = self.base_address + 70;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::IrqStatus3,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::IrqStatus3::new)
            }
            ///Interrupt Status 4.
            pub fn irq_status_4(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::IrqStatus4,
                ::device_driver::RW,
            > {
                let address = self.base_address + 71;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::IrqStatus4,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::IrqStatus4::new)
            }
            ///Interrupt Status 5.
            pub fn irq_status_5(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::IrqStatus5,
                ::device_driver::RW,
            > {
                let address = self.base_address + 77;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::IrqStatus5,
                    ::device_driver::RW,
                >::new(self.interface(), address as u8, field_sets::IrqStatus5::new)
            }
            ///
            pub fn acin_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::AcinVoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 86;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::AcinVoltageAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::AcinVoltageAdc::new)
            }
            ///
            pub fn acin_current_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::AcinCurrentAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 88;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::AcinCurrentAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::AcinCurrentAdc::new)
            }
            ///
            pub fn vbus_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::VbusVoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 90;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::VbusVoltageAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::VbusVoltageAdc::new)
            }
            ///
            pub fn vbus_current_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::VbusCurrentAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 92;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::VbusCurrentAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::VbusCurrentAdc::new)
            }
            ///
            pub fn internal_temperature_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::InternalTemperatureAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 94;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::InternalTemperatureAdc,
                    ::device_driver::RO,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::InternalTemperatureAdc::new,
                )
            }
            ///
            pub fn ts_input_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::TsInputAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 98;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::TsInputAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::TsInputAdc::new)
            }
            ///
            pub fn gpio_0_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio0VoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 100;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio0VoltageAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::Gpio0VoltageAdc::new)
            }
            ///
            pub fn gpio_1_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio1VoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 102;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio1VoltageAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::Gpio1VoltageAdc::new)
            }
            ///
            pub fn gpio_2_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio2VoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 104;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio2VoltageAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::Gpio2VoltageAdc::new)
            }
            ///
            pub fn gpio_3_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::Gpio3VoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 106;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::Gpio3VoltageAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::Gpio3VoltageAdc::new)
            }
            ///Battery power ADC raw value (23-bit result).
            pub fn battery_power_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::BatteryPowerAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 112;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::BatteryPowerAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::BatteryPowerAdc::new)
            }
            ///
            pub fn battery_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::BatteryVoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 120;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::BatteryVoltageAdc,
                    ::device_driver::RO,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::BatteryVoltageAdc::new,
                )
            }
            ///
            pub fn charge_current_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ChargeCurrentAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 122;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ChargeCurrentAdc,
                    ::device_driver::RO,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::ChargeCurrentAdc::new,
                )
            }
            ///
            pub fn discharge_current_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DischargeCurrentAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 124;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DischargeCurrentAdc,
                    ::device_driver::RO,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::DischargeCurrentAdc::new,
                )
            }
            ///
            pub fn aps_voltage_adc(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ApsVoltageAdc,
                ::device_driver::RO,
            > {
                let address = self.base_address + 126;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ApsVoltageAdc,
                    ::device_driver::RO,
                >::new(self.interface(), address as u8, field_sets::ApsVoltageAdc::new)
            }
            ///Charge coulomb counter value.
            pub fn charge_coulomb_counter(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::ChargeCoulombCounter,
                ::device_driver::RO,
            > {
                let address = self.base_address + 176;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::ChargeCoulombCounter,
                    ::device_driver::RO,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::ChargeCoulombCounter::new,
                )
            }
            ///Discharge coulomb counter value.
            pub fn discharge_coulomb_counter(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::DischargeCoulombCounter,
                ::device_driver::RO,
            > {
                let address = self.base_address + 180;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::DischargeCoulombCounter,
                    ::device_driver::RO,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::DischargeCoulombCounter::new,
                )
            }
            ///Coulomb counter control.
            pub fn coulomb_counter_control(
                &mut self,
            ) -> ::device_driver::RegisterOperation<
                '_,
                I,
                u8,
                field_sets::CoulombCounterControl,
                ::device_driver::RW,
            > {
                let address = self.base_address + 184;
                ::device_driver::RegisterOperation::<
                    '_,
                    I,
                    u8,
                    field_sets::CoulombCounterControl,
                    ::device_driver::RW,
                >::new(
                    self.interface(),
                    address as u8,
                    field_sets::CoulombCounterControl::new,
                )
            }
        }
        /// Module containing the generated fieldsets of the registers and commands
        pub mod field_sets {
            use super::*;
            ///Input power status.
            pub struct PowerStatus {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for PowerStatus {}
            #[automatically_derived]
            impl ::core::clone::Clone for PowerStatus {
                #[inline]
                fn clone(&self) -> PowerStatus {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for PowerStatus {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PowerStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PowerStatus {
                #[inline]
                fn eq(&self, other: &PowerStatus) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for PowerStatus {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl PowerStatus {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `acin_present` field of the register.
                ///
                ///ACIN presence (1: exist)
                pub fn acin_present(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `acin_usable` field of the register.
                ///
                ///ACIN usable (1: usable)
                pub fn acin_usable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `vbus_present` field of the register.
                ///
                ///VBUS presence (1: exist)
                pub fn vbus_present(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Read the `vbus_usable` field of the register.
                ///
                ///VBUS usable (1: usable)
                pub fn vbus_usable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 4)
                    };
                    raw > 0
                }
                ///Read the `vbus_path_select_status` field of the register.
                ///
                ///VBUS path select status (0: not used, 1: used)
                pub fn vbus_path_select_status(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 5)
                    };
                    raw > 0
                }
                ///Read the `battery_current_direction` field of the register.
                ///
                ///Battery current (0: Discharge, 1: Charge)
                pub fn battery_current_direction(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 6)
                    };
                    raw > 0
                }
                ///Read the `boot_source_acin_vbus` field of the register.
                ///
                ///Boot source (0: Battery, 1: ACIN/VBUS)
                pub fn boot_source_acin_vbus(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 6, 7)
                    };
                    raw > 0
                }
                ///Read the `acin_vbus_short_to_gnd` field of the register.
                ///
                ///ACIN/VBUS short to ground (0: No, 1: Yes)
                pub fn acin_vbus_short_to_gnd(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 7, 8)
                    };
                    raw > 0
                }
                ///Write the `acin_present` field of the register.
                ///
                ///ACIN presence (1: exist)
                pub fn set_acin_present(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `acin_usable` field of the register.
                ///
                ///ACIN usable (1: usable)
                pub fn set_acin_usable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `vbus_present` field of the register.
                ///
                ///VBUS presence (1: exist)
                pub fn set_vbus_present(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
                ///Write the `vbus_usable` field of the register.
                ///
                ///VBUS usable (1: usable)
                pub fn set_vbus_usable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 4, &mut self.bits)
                    };
                }
                ///Write the `vbus_path_select_status` field of the register.
                ///
                ///VBUS path select status (0: not used, 1: used)
                pub fn set_vbus_path_select_status(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 5, &mut self.bits)
                    };
                }
                ///Write the `battery_current_direction` field of the register.
                ///
                ///Battery current (0: Discharge, 1: Charge)
                pub fn set_battery_current_direction(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 6, &mut self.bits)
                    };
                }
                ///Write the `boot_source_acin_vbus` field of the register.
                ///
                ///Boot source (0: Battery, 1: ACIN/VBUS)
                pub fn set_boot_source_acin_vbus(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 6, 7, &mut self.bits)
                    };
                }
                ///Write the `acin_vbus_short_to_gnd` field of the register.
                ///
                ///ACIN/VBUS short to ground (0: No, 1: Yes)
                pub fn set_acin_vbus_short_to_gnd(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 7, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for PowerStatus {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<PowerStatus> for [u8; 1] {
                fn from(val: PowerStatus) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for PowerStatus {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("PowerStatus")
                        .field("acin_present", &self.acin_present())
                        .field("acin_usable", &self.acin_usable())
                        .field("vbus_present", &self.vbus_present())
                        .field("vbus_usable", &self.vbus_usable())
                        .field(
                            "vbus_path_select_status",
                            &self.vbus_path_select_status(),
                        )
                        .field(
                            "battery_current_direction",
                            &self.battery_current_direction(),
                        )
                        .field("boot_source_acin_vbus", &self.boot_source_acin_vbus())
                        .field("acin_vbus_short_to_gnd", &self.acin_vbus_short_to_gnd())
                        .finish()
                }
            }
            impl core::ops::BitAnd for PowerStatus {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for PowerStatus {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for PowerStatus {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for PowerStatus {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for PowerStatus {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for PowerStatus {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for PowerStatus {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Charging and battery status.
            pub struct ChargeStatus {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ChargeStatus {}
            #[automatically_derived]
            impl ::core::clone::Clone for ChargeStatus {
                #[inline]
                fn clone(&self) -> ChargeStatus {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ChargeStatus {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ChargeStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ChargeStatus {
                #[inline]
                fn eq(&self, other: &ChargeStatus) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ChargeStatus {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ChargeStatus {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `battery_charging_indication` field of the register.
                ///
                ///Battery is charging (1: Yes)
                pub fn battery_charging_indication(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `battery_present_or_temp_ok` field of the register.
                ///
                ///Battery present/activated or temperature qualified
                pub fn battery_present_or_temp_ok(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Write the `battery_charging_indication` field of the register.
                ///
                ///Battery is charging (1: Yes)
                pub fn set_battery_charging_indication(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `battery_present_or_temp_ok` field of the register.
                ///
                ///Battery present/activated or temperature qualified
                pub fn set_battery_present_or_temp_ok(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for ChargeStatus {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ChargeStatus> for [u8; 1] {
                fn from(val: ChargeStatus) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ChargeStatus {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ChargeStatus")
                        .field(
                            "battery_charging_indication",
                            &self.battery_charging_indication(),
                        )
                        .field(
                            "battery_present_or_temp_ok",
                            &self.battery_present_or_temp_ok(),
                        )
                        .finish()
                }
            }
            impl core::ops::BitAnd for ChargeStatus {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ChargeStatus {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ChargeStatus {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ChargeStatus {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ChargeStatus {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ChargeStatus {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ChargeStatus {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///OTG VBUS status.
            pub struct OtgVbusStatus {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for OtgVbusStatus {}
            #[automatically_derived]
            impl ::core::clone::Clone for OtgVbusStatus {
                #[inline]
                fn clone(&self) -> OtgVbusStatus {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for OtgVbusStatus {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for OtgVbusStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for OtgVbusStatus {
                #[inline]
                fn eq(&self, other: &OtgVbusStatus) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for OtgVbusStatus {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl OtgVbusStatus {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `otg_vbus_valid` field of the register.
                ///
                ///
                pub fn otg_vbus_valid(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `session_ab_valid` field of the register.
                ///
                ///
                pub fn session_ab_valid(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Write the `otg_vbus_valid` field of the register.
                ///
                ///
                pub fn set_otg_vbus_valid(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `session_ab_valid` field of the register.
                ///
                ///
                pub fn set_session_ab_valid(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for OtgVbusStatus {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<OtgVbusStatus> for [u8; 1] {
                fn from(val: OtgVbusStatus) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for OtgVbusStatus {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("OtgVbusStatus")
                        .field("otg_vbus_valid", &self.otg_vbus_valid())
                        .field("session_ab_valid", &self.session_ab_valid())
                        .finish()
                }
            }
            impl core::ops::BitAnd for OtgVbusStatus {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for OtgVbusStatus {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for OtgVbusStatus {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for OtgVbusStatus {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for OtgVbusStatus {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for OtgVbusStatus {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for OtgVbusStatus {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Data Buffer 0
            pub struct DataBuffer0 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DataBuffer0 {}
            #[automatically_derived]
            impl ::core::clone::Clone for DataBuffer0 {
                #[inline]
                fn clone(&self) -> DataBuffer0 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DataBuffer0 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DataBuffer0 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DataBuffer0 {
                #[inline]
                fn eq(&self, other: &DataBuffer0) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DataBuffer0 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DataBuffer0 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DataBuffer0 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DataBuffer0> for [u8; 1] {
                fn from(val: DataBuffer0) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DataBuffer0 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DataBuffer0").finish()
                }
            }
            impl core::ops::BitAnd for DataBuffer0 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DataBuffer0 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DataBuffer0 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DataBuffer0 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DataBuffer0 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DataBuffer0 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DataBuffer0 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Data Buffer 1
            pub struct DataBuffer1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DataBuffer1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for DataBuffer1 {
                #[inline]
                fn clone(&self) -> DataBuffer1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DataBuffer1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DataBuffer1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DataBuffer1 {
                #[inline]
                fn eq(&self, other: &DataBuffer1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DataBuffer1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DataBuffer1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DataBuffer1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DataBuffer1> for [u8; 1] {
                fn from(val: DataBuffer1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DataBuffer1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DataBuffer1").finish()
                }
            }
            impl core::ops::BitAnd for DataBuffer1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DataBuffer1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DataBuffer1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DataBuffer1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DataBuffer1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DataBuffer1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DataBuffer1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Data Buffer 2
            pub struct DataBuffer2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DataBuffer2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for DataBuffer2 {
                #[inline]
                fn clone(&self) -> DataBuffer2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DataBuffer2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DataBuffer2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DataBuffer2 {
                #[inline]
                fn eq(&self, other: &DataBuffer2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DataBuffer2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DataBuffer2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DataBuffer2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DataBuffer2> for [u8; 1] {
                fn from(val: DataBuffer2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DataBuffer2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DataBuffer2").finish()
                }
            }
            impl core::ops::BitAnd for DataBuffer2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DataBuffer2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DataBuffer2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DataBuffer2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DataBuffer2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DataBuffer2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DataBuffer2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Data Buffer 3
            pub struct DataBuffer3 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DataBuffer3 {}
            #[automatically_derived]
            impl ::core::clone::Clone for DataBuffer3 {
                #[inline]
                fn clone(&self) -> DataBuffer3 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DataBuffer3 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DataBuffer3 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DataBuffer3 {
                #[inline]
                fn eq(&self, other: &DataBuffer3) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DataBuffer3 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DataBuffer3 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DataBuffer3 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DataBuffer3> for [u8; 1] {
                fn from(val: DataBuffer3) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DataBuffer3 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DataBuffer3").finish()
                }
            }
            impl core::ops::BitAnd for DataBuffer3 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DataBuffer3 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DataBuffer3 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DataBuffer3 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DataBuffer3 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DataBuffer3 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DataBuffer3 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Data Buffer 4
            pub struct DataBuffer4 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DataBuffer4 {}
            #[automatically_derived]
            impl ::core::clone::Clone for DataBuffer4 {
                #[inline]
                fn clone(&self) -> DataBuffer4 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DataBuffer4 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DataBuffer4 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DataBuffer4 {
                #[inline]
                fn eq(&self, other: &DataBuffer4) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DataBuffer4 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DataBuffer4 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DataBuffer4 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DataBuffer4> for [u8; 1] {
                fn from(val: DataBuffer4) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DataBuffer4 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DataBuffer4").finish()
                }
            }
            impl core::ops::BitAnd for DataBuffer4 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DataBuffer4 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DataBuffer4 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DataBuffer4 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DataBuffer4 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DataBuffer4 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DataBuffer4 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Data Buffer 5
            pub struct DataBuffer5 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DataBuffer5 {}
            #[automatically_derived]
            impl ::core::clone::Clone for DataBuffer5 {
                #[inline]
                fn clone(&self) -> DataBuffer5 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DataBuffer5 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DataBuffer5 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DataBuffer5 {
                #[inline]
                fn eq(&self, other: &DataBuffer5) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DataBuffer5 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DataBuffer5 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DataBuffer5 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DataBuffer5> for [u8; 1] {
                fn from(val: DataBuffer5) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DataBuffer5 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DataBuffer5").finish()
                }
            }
            impl core::ops::BitAnd for DataBuffer5 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DataBuffer5 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DataBuffer5 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DataBuffer5 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DataBuffer5 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DataBuffer5 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DataBuffer5 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///EXTEN and DC-DC2 enable control.
            pub struct ExtenDcdc2Control {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ExtenDcdc2Control {}
            #[automatically_derived]
            impl ::core::clone::Clone for ExtenDcdc2Control {
                #[inline]
                fn clone(&self) -> ExtenDcdc2Control {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ExtenDcdc2Control {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ExtenDcdc2Control {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ExtenDcdc2Control {
                #[inline]
                fn eq(&self, other: &ExtenDcdc2Control) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ExtenDcdc2Control {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ExtenDcdc2Control {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `exten_enable` field of the register.
                ///
                ///EXTEN output enable switch
                pub fn exten_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `dcdc_2_enable` field of the register.
                ///
                ///DC-DC2 output enable switch
                pub fn dcdc_2_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 4)
                    };
                    raw > 0
                }
                ///Write the `exten_enable` field of the register.
                ///
                ///EXTEN output enable switch
                pub fn set_exten_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `dcdc_2_enable` field of the register.
                ///
                ///DC-DC2 output enable switch
                pub fn set_dcdc_2_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 4, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for ExtenDcdc2Control {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ExtenDcdc2Control> for [u8; 1] {
                fn from(val: ExtenDcdc2Control) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ExtenDcdc2Control {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ExtenDcdc2Control")
                        .field("exten_enable", &self.exten_enable())
                        .field("dcdc_2_enable", &self.dcdc_2_enable())
                        .finish()
                }
            }
            impl core::ops::BitAnd for ExtenDcdc2Control {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ExtenDcdc2Control {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ExtenDcdc2Control {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ExtenDcdc2Control {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ExtenDcdc2Control {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ExtenDcdc2Control {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ExtenDcdc2Control {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Power output control for DCDC1/3, LDO2/3. Note: DCDC2/EXTEN control also here.
            pub struct Dcdc13Ldo23Control {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Dcdc13Ldo23Control {}
            #[automatically_derived]
            impl ::core::clone::Clone for Dcdc13Ldo23Control {
                #[inline]
                fn clone(&self) -> Dcdc13Ldo23Control {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Dcdc13Ldo23Control {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Dcdc13Ldo23Control {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Dcdc13Ldo23Control {
                #[inline]
                fn eq(&self, other: &Dcdc13Ldo23Control) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Dcdc13Ldo23Control {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Dcdc13Ldo23Control {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `exten_enable_alt` field of the register.
                ///
                ///EXTEN enable (alternative bit, prefer 0x10)
                pub fn exten_enable_alt(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `dcdc_2_enable_alt` field of the register.
                ///
                ///DCDC2 enable (alternative bit, prefer 0x10)
                pub fn dcdc_2_enable_alt(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 4)
                    };
                    raw > 0
                }
                ///Read the `ldo_3_enable` field of the register.
                ///
                ///LDO3 output enable
                pub fn ldo_3_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 5)
                    };
                    raw > 0
                }
                ///Read the `ldo_2_enable` field of the register.
                ///
                ///LDO2 output enable
                pub fn ldo_2_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 6)
                    };
                    raw > 0
                }
                ///Read the `dcdc_3_enable` field of the register.
                ///
                ///DC-DC3 output enable
                pub fn dcdc_3_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 6, 7)
                    };
                    raw > 0
                }
                ///Read the `dcdc_1_enable` field of the register.
                ///
                ///DC-DC1 output enable
                pub fn dcdc_1_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 7, 8)
                    };
                    raw > 0
                }
                ///Write the `exten_enable_alt` field of the register.
                ///
                ///EXTEN enable (alternative bit, prefer 0x10)
                pub fn set_exten_enable_alt(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `dcdc_2_enable_alt` field of the register.
                ///
                ///DCDC2 enable (alternative bit, prefer 0x10)
                pub fn set_dcdc_2_enable_alt(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 4, &mut self.bits)
                    };
                }
                ///Write the `ldo_3_enable` field of the register.
                ///
                ///LDO3 output enable
                pub fn set_ldo_3_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 5, &mut self.bits)
                    };
                }
                ///Write the `ldo_2_enable` field of the register.
                ///
                ///LDO2 output enable
                pub fn set_ldo_2_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 6, &mut self.bits)
                    };
                }
                ///Write the `dcdc_3_enable` field of the register.
                ///
                ///DC-DC3 output enable
                pub fn set_dcdc_3_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 6, 7, &mut self.bits)
                    };
                }
                ///Write the `dcdc_1_enable` field of the register.
                ///
                ///DC-DC1 output enable
                pub fn set_dcdc_1_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 7, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Dcdc13Ldo23Control {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Dcdc13Ldo23Control> for [u8; 1] {
                fn from(val: Dcdc13Ldo23Control) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Dcdc13Ldo23Control {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Dcdc13Ldo23Control")
                        .field("exten_enable_alt", &self.exten_enable_alt())
                        .field("dcdc_2_enable_alt", &self.dcdc_2_enable_alt())
                        .field("ldo_3_enable", &self.ldo_3_enable())
                        .field("ldo_2_enable", &self.ldo_2_enable())
                        .field("dcdc_3_enable", &self.dcdc_3_enable())
                        .field("dcdc_1_enable", &self.dcdc_1_enable())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Dcdc13Ldo23Control {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Dcdc13Ldo23Control {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Dcdc13Ldo23Control {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Dcdc13Ldo23Control {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Dcdc13Ldo23Control {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Dcdc13Ldo23Control {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Dcdc13Ldo23Control {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///DC-DC2 output voltage setting (0.7-2.275V or 0.7-3.5V, 25mV/step - check datasheet for your variant).
            pub struct Dcdc2Voltage {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Dcdc2Voltage {}
            #[automatically_derived]
            impl ::core::clone::Clone for Dcdc2Voltage {
                #[inline]
                fn clone(&self) -> Dcdc2Voltage {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Dcdc2Voltage {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Dcdc2Voltage {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Dcdc2Voltage {
                #[inline]
                fn eq(&self, other: &Dcdc2Voltage) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Dcdc2Voltage {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Dcdc2Voltage {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `setting` field of the register.
                ///
                ///Voltage setting bits (0-6 or 0-5 for 64 steps)
                pub fn setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 8)
                    };
                    raw
                }
                ///Write the `setting` field of the register.
                ///
                ///Voltage setting bits (0-6 or 0-5 for 64 steps)
                pub fn set_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Dcdc2Voltage {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Dcdc2Voltage> for [u8; 1] {
                fn from(val: Dcdc2Voltage) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Dcdc2Voltage {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Dcdc2Voltage")
                        .field("setting", &self.setting())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Dcdc2Voltage {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Dcdc2Voltage {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Dcdc2Voltage {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Dcdc2Voltage {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Dcdc2Voltage {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Dcdc2Voltage {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Dcdc2Voltage {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///DC-DC2 VRC slope control.
            pub struct Dcdc2Slope {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Dcdc2Slope {}
            #[automatically_derived]
            impl ::core::clone::Clone for Dcdc2Slope {
                #[inline]
                fn clone(&self) -> Dcdc2Slope {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Dcdc2Slope {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Dcdc2Slope {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Dcdc2Slope {
                #[inline]
                fn eq(&self, other: &Dcdc2Slope) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Dcdc2Slope {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Dcdc2Slope {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Dcdc2Slope {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Dcdc2Slope> for [u8; 1] {
                fn from(val: Dcdc2Slope) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Dcdc2Slope {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Dcdc2Slope").finish()
                }
            }
            impl core::ops::BitAnd for Dcdc2Slope {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Dcdc2Slope {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Dcdc2Slope {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Dcdc2Slope {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Dcdc2Slope {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Dcdc2Slope {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Dcdc2Slope {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///DC-DC1 output voltage setting (0.7-3.5V, 25mV/step).
            pub struct Dcdc1Voltage {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Dcdc1Voltage {}
            #[automatically_derived]
            impl ::core::clone::Clone for Dcdc1Voltage {
                #[inline]
                fn clone(&self) -> Dcdc1Voltage {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Dcdc1Voltage {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Dcdc1Voltage {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Dcdc1Voltage {
                #[inline]
                fn eq(&self, other: &Dcdc1Voltage) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Dcdc1Voltage {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Dcdc1Voltage {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `setting` field of the register.
                ///
                ///Voltage setting bits (0-6)
                pub fn setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 8)
                    };
                    raw
                }
                ///Write the `setting` field of the register.
                ///
                ///Voltage setting bits (0-6)
                pub fn set_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Dcdc1Voltage {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Dcdc1Voltage> for [u8; 1] {
                fn from(val: Dcdc1Voltage) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Dcdc1Voltage {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Dcdc1Voltage")
                        .field("setting", &self.setting())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Dcdc1Voltage {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Dcdc1Voltage {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Dcdc1Voltage {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Dcdc1Voltage {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Dcdc1Voltage {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Dcdc1Voltage {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Dcdc1Voltage {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///DC-DC3 output voltage setting (0.7-3.5V, 25mV/step).
            pub struct Dcdc3Voltage {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Dcdc3Voltage {}
            #[automatically_derived]
            impl ::core::clone::Clone for Dcdc3Voltage {
                #[inline]
                fn clone(&self) -> Dcdc3Voltage {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Dcdc3Voltage {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Dcdc3Voltage {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Dcdc3Voltage {
                #[inline]
                fn eq(&self, other: &Dcdc3Voltage) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Dcdc3Voltage {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Dcdc3Voltage {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `setting` field of the register.
                ///
                ///Voltage setting bits (0-6)
                pub fn setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 8)
                    };
                    raw
                }
                ///Write the `setting` field of the register.
                ///
                ///Voltage setting bits (0-6)
                pub fn set_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Dcdc3Voltage {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Dcdc3Voltage> for [u8; 1] {
                fn from(val: Dcdc3Voltage) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Dcdc3Voltage {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Dcdc3Voltage")
                        .field("setting", &self.setting())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Dcdc3Voltage {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Dcdc3Voltage {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Dcdc3Voltage {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Dcdc3Voltage {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Dcdc3Voltage {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Dcdc3Voltage {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Dcdc3Voltage {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///LDO2/LDO3 output voltage settings (1.8-3.3V, 100mV/step).
            pub struct Ldo23Voltage {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Ldo23Voltage {}
            #[automatically_derived]
            impl ::core::clone::Clone for Ldo23Voltage {
                #[inline]
                fn clone(&self) -> Ldo23Voltage {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Ldo23Voltage {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Ldo23Voltage {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Ldo23Voltage {
                #[inline]
                fn eq(&self, other: &Ldo23Voltage) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Ldo23Voltage {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Ldo23Voltage {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `ldo_2_setting` field of the register.
                ///
                ///LDO2 voltage setting (bits 7-4)
                pub fn ldo_2_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 4)
                    };
                    raw
                }
                ///Read the `ldo_3_setting` field of the register.
                ///
                ///LDO3 voltage setting (bits 3-0)
                pub fn ldo_3_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 8)
                    };
                    raw
                }
                ///Write the `ldo_2_setting` field of the register.
                ///
                ///LDO2 voltage setting (bits 7-4)
                pub fn set_ldo_2_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 4, &mut self.bits)
                    };
                }
                ///Write the `ldo_3_setting` field of the register.
                ///
                ///LDO3 voltage setting (bits 3-0)
                pub fn set_ldo_3_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Ldo23Voltage {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Ldo23Voltage> for [u8; 1] {
                fn from(val: Ldo23Voltage) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Ldo23Voltage {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Ldo23Voltage")
                        .field("ldo_2_setting", &self.ldo_2_setting())
                        .field("ldo_3_setting", &self.ldo_3_setting())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Ldo23Voltage {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Ldo23Voltage {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Ldo23Voltage {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Ldo23Voltage {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Ldo23Voltage {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Ldo23Voltage {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Ldo23Voltage {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///VBUS-IPSOUT path control and VBUS current limit.
            pub struct VbusIpsoutChannel {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for VbusIpsoutChannel {}
            #[automatically_derived]
            impl ::core::clone::Clone for VbusIpsoutChannel {
                #[inline]
                fn clone(&self) -> VbusIpsoutChannel {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for VbusIpsoutChannel {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VbusIpsoutChannel {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for VbusIpsoutChannel {
                #[inline]
                fn eq(&self, other: &VbusIpsoutChannel) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for VbusIpsoutChannel {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl VbusIpsoutChannel {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `vbus_ipsout_path_select_override` field of the register.
                ///
                ///
                pub fn vbus_ipsout_path_select_override(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `vbus_current_limit` field of the register.
                ///
                ///VBUS current limit (0: 900mA, 1: 500mA)
                pub fn vbus_current_limit(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `vhold_voltage_setting` field of the register.
                ///
                ///
                pub fn vhold_voltage_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 8)
                    };
                    raw
                }
                ///Write the `vbus_ipsout_path_select_override` field of the register.
                ///
                ///
                pub fn set_vbus_ipsout_path_select_override(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `vbus_current_limit` field of the register.
                ///
                ///VBUS current limit (0: 900mA, 1: 500mA)
                pub fn set_vbus_current_limit(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `vhold_voltage_setting` field of the register.
                ///
                ///
                pub fn set_vhold_voltage_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for VbusIpsoutChannel {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<VbusIpsoutChannel> for [u8; 1] {
                fn from(val: VbusIpsoutChannel) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for VbusIpsoutChannel {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("VbusIpsoutChannel")
                        .field(
                            "vbus_ipsout_path_select_override",
                            &self.vbus_ipsout_path_select_override(),
                        )
                        .field("vbus_current_limit", &self.vbus_current_limit())
                        .field("vhold_voltage_setting", &self.vhold_voltage_setting())
                        .finish()
                }
            }
            impl core::ops::BitAnd for VbusIpsoutChannel {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for VbusIpsoutChannel {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for VbusIpsoutChannel {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for VbusIpsoutChannel {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for VbusIpsoutChannel {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for VbusIpsoutChannel {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for VbusIpsoutChannel {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Voff shutdown voltage and Pek function control.
            pub struct ShutdownVoltage {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ShutdownVoltage {}
            #[automatically_derived]
            impl ::core::clone::Clone for ShutdownVoltage {
                #[inline]
                fn clone(&self) -> ShutdownVoltage {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ShutdownVoltage {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ShutdownVoltage {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ShutdownVoltage {
                #[inline]
                fn eq(&self, other: &ShutdownVoltage) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ShutdownVoltage {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ShutdownVoltage {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `voff_shutdown_voltage` field of the register.
                ///
                ///
                pub fn voff_shutdown_voltage(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 3)
                    };
                    raw
                }
                ///Read the `pek_function_select` field of the register.
                ///
                ///
                pub fn pek_function_select(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 5)
                    };
                    raw
                }
                ///Write the `voff_shutdown_voltage` field of the register.
                ///
                ///
                pub fn set_voff_shutdown_voltage(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 3, &mut self.bits)
                    };
                }
                ///Write the `pek_function_select` field of the register.
                ///
                ///
                pub fn set_pek_function_select(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 5, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for ShutdownVoltage {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ShutdownVoltage> for [u8; 1] {
                fn from(val: ShutdownVoltage) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ShutdownVoltage {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ShutdownVoltage")
                        .field("voff_shutdown_voltage", &self.voff_shutdown_voltage())
                        .field("pek_function_select", &self.pek_function_select())
                        .finish()
                }
            }
            impl core::ops::BitAnd for ShutdownVoltage {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ShutdownVoltage {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ShutdownVoltage {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ShutdownVoltage {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ShutdownVoltage {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ShutdownVoltage {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ShutdownVoltage {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Shutdown behavior, CHGLED control.
            pub struct ShutdownBatteryChgledControl {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ShutdownBatteryChgledControl {}
            #[automatically_derived]
            impl ::core::clone::Clone for ShutdownBatteryChgledControl {
                #[inline]
                fn clone(&self) -> ShutdownBatteryChgledControl {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ShutdownBatteryChgledControl {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ShutdownBatteryChgledControl {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ShutdownBatteryChgledControl {
                #[inline]
                fn eq(&self, other: &ShutdownBatteryChgledControl) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ShutdownBatteryChgledControl {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ShutdownBatteryChgledControl {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `shutdown_timing` field of the register.
                ///
                ///Shutdown timing options (bits 7-6)
                pub fn shutdown_timing(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 2)
                    };
                    raw
                }
                ///Read the `shutdown_enable` field of the register.
                ///
                ///Shutdown function enable (1: enable)
                pub fn shutdown_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Read the `chgled_control_mode` field of the register.
                ///
                ///CHGLED pin control mode (bits 3-2)
                pub fn chgled_control_mode(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 6)
                    };
                    raw
                }
                ///Write the `shutdown_timing` field of the register.
                ///
                ///Shutdown timing options (bits 7-6)
                pub fn set_shutdown_timing(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 2, &mut self.bits)
                    };
                }
                ///Write the `shutdown_enable` field of the register.
                ///
                ///Shutdown function enable (1: enable)
                pub fn set_shutdown_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
                ///Write the `chgled_control_mode` field of the register.
                ///
                ///CHGLED pin control mode (bits 3-2)
                pub fn set_chgled_control_mode(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 6, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for ShutdownBatteryChgledControl {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ShutdownBatteryChgledControl> for [u8; 1] {
                fn from(val: ShutdownBatteryChgledControl) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ShutdownBatteryChgledControl {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ShutdownBatteryChgledControl")
                        .field("shutdown_timing", &self.shutdown_timing())
                        .field("shutdown_enable", &self.shutdown_enable())
                        .field("chgled_control_mode", &self.chgled_control_mode())
                        .finish()
                }
            }
            impl core::ops::BitAnd for ShutdownBatteryChgledControl {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ShutdownBatteryChgledControl {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ShutdownBatteryChgledControl {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ShutdownBatteryChgledControl {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ShutdownBatteryChgledControl {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ShutdownBatteryChgledControl {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ShutdownBatteryChgledControl {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Charging control 1: target voltage, current, end current.
            pub struct ChargeControl1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ChargeControl1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for ChargeControl1 {
                #[inline]
                fn clone(&self) -> ChargeControl1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ChargeControl1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ChargeControl1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ChargeControl1 {
                #[inline]
                fn eq(&self, other: &ChargeControl1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ChargeControl1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ChargeControl1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `charge_enable` field of the register.
                ///
                ///
                pub fn charge_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `charge_target_voltage` field of the register.
                ///
                ///Target voltage (bits 6-5)
                pub fn charge_target_voltage(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 3)
                    };
                    raw
                }
                ///Read the `end_charge_current_setting` field of the register.
                ///
                ///
                pub fn end_charge_current_setting(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 4)
                    };
                    raw > 0
                }
                ///Read the `charge_current_setting` field of the register.
                ///
                ///Charge current (bits 3-0)
                pub fn charge_current_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 8)
                    };
                    raw
                }
                ///Write the `charge_enable` field of the register.
                ///
                ///
                pub fn set_charge_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `charge_target_voltage` field of the register.
                ///
                ///Target voltage (bits 6-5)
                pub fn set_charge_target_voltage(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 3, &mut self.bits)
                    };
                }
                ///Write the `end_charge_current_setting` field of the register.
                ///
                ///
                pub fn set_end_charge_current_setting(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 4, &mut self.bits)
                    };
                }
                ///Write the `charge_current_setting` field of the register.
                ///
                ///Charge current (bits 3-0)
                pub fn set_charge_current_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for ChargeControl1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ChargeControl1> for [u8; 1] {
                fn from(val: ChargeControl1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ChargeControl1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ChargeControl1")
                        .field("charge_enable", &self.charge_enable())
                        .field("charge_target_voltage", &self.charge_target_voltage())
                        .field(
                            "end_charge_current_setting",
                            &self.end_charge_current_setting(),
                        )
                        .field("charge_current_setting", &self.charge_current_setting())
                        .finish()
                }
            }
            impl core::ops::BitAnd for ChargeControl1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ChargeControl1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ChargeControl1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ChargeControl1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ChargeControl1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ChargeControl1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ChargeControl1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Charging control 2: pre-charge time, constant current timeout.
            pub struct ChargeControl2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ChargeControl2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for ChargeControl2 {
                #[inline]
                fn clone(&self) -> ChargeControl2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ChargeControl2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ChargeControl2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ChargeControl2 {
                #[inline]
                fn eq(&self, other: &ChargeControl2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ChargeControl2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ChargeControl2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `constant_current_timeout` field of the register.
                ///
                ///
                pub fn constant_current_timeout(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 2)
                    };
                    raw
                }
                ///Write the `constant_current_timeout` field of the register.
                ///
                ///
                pub fn set_constant_current_timeout(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 2, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for ChargeControl2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ChargeControl2> for [u8; 1] {
                fn from(val: ChargeControl2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ChargeControl2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ChargeControl2")
                        .field(
                            "constant_current_timeout",
                            &self.constant_current_timeout(),
                        )
                        .finish()
                }
            }
            impl core::ops::BitAnd for ChargeControl2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ChargeControl2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ChargeControl2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ChargeControl2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ChargeControl2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ChargeControl2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ChargeControl2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Backup battery charging control and other battery features.
            pub struct BatteryChargeControl {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BatteryChargeControl {}
            #[automatically_derived]
            impl ::core::clone::Clone for BatteryChargeControl {
                #[inline]
                fn clone(&self) -> BatteryChargeControl {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BatteryChargeControl {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BatteryChargeControl {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BatteryChargeControl {
                #[inline]
                fn eq(&self, other: &BatteryChargeControl) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for BatteryChargeControl {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl BatteryChargeControl {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `backup_battery_charge_enable` field of the register.
                ///
                ///
                pub fn backup_battery_charge_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Write the `backup_battery_charge_enable` field of the register.
                ///
                ///
                pub fn set_backup_battery_charge_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for BatteryChargeControl {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<BatteryChargeControl> for [u8; 1] {
                fn from(val: BatteryChargeControl) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for BatteryChargeControl {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("BatteryChargeControl")
                        .field(
                            "backup_battery_charge_enable",
                            &self.backup_battery_charge_enable(),
                        )
                        .finish()
                }
            }
            impl core::ops::BitAnd for BatteryChargeControl {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for BatteryChargeControl {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for BatteryChargeControl {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for BatteryChargeControl {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for BatteryChargeControl {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for BatteryChargeControl {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for BatteryChargeControl {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///PEK button settings: boot/shutdown times, power on/off behavior.
            pub struct PekSettings {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for PekSettings {}
            #[automatically_derived]
            impl ::core::clone::Clone for PekSettings {
                #[inline]
                fn clone(&self) -> PekSettings {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for PekSettings {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PekSettings {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PekSettings {
                #[inline]
                fn eq(&self, other: &PekSettings) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for PekSettings {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl PekSettings {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `boot_time_setting` field of the register.
                ///
                ///
                pub fn boot_time_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 2)
                    };
                    raw
                }
                ///Read the `long_press_time_setting` field of the register.
                ///
                ///
                pub fn long_press_time_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 4)
                    };
                    raw
                }
                ///Read the `auto_shutdown_by_pwrok_en` field of the register.
                ///
                ///
                pub fn auto_shutdown_by_pwrok_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 5)
                    };
                    raw > 0
                }
                ///Read the `pwrok_signal_delay` field of the register.
                ///
                ///PWROK signal delay (0:32ms, 1:64ms, this field is 1 bit in many datasheets, check yours)
                pub fn pwrok_signal_delay(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 6)
                    };
                    raw
                }
                ///Read the `shutdown_duration_setting` field of the register.
                ///
                ///
                pub fn shutdown_duration_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 6, 8)
                    };
                    raw
                }
                ///Write the `boot_time_setting` field of the register.
                ///
                ///
                pub fn set_boot_time_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 2, &mut self.bits)
                    };
                }
                ///Write the `long_press_time_setting` field of the register.
                ///
                ///
                pub fn set_long_press_time_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 4, &mut self.bits)
                    };
                }
                ///Write the `auto_shutdown_by_pwrok_en` field of the register.
                ///
                ///
                pub fn set_auto_shutdown_by_pwrok_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 5, &mut self.bits)
                    };
                }
                ///Write the `pwrok_signal_delay` field of the register.
                ///
                ///PWROK signal delay (0:32ms, 1:64ms, this field is 1 bit in many datasheets, check yours)
                pub fn set_pwrok_signal_delay(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 6, &mut self.bits)
                    };
                }
                ///Write the `shutdown_duration_setting` field of the register.
                ///
                ///
                pub fn set_shutdown_duration_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 6, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for PekSettings {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<PekSettings> for [u8; 1] {
                fn from(val: PekSettings) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for PekSettings {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("PekSettings")
                        .field("boot_time_setting", &self.boot_time_setting())
                        .field(
                            "long_press_time_setting",
                            &self.long_press_time_setting(),
                        )
                        .field(
                            "auto_shutdown_by_pwrok_en",
                            &self.auto_shutdown_by_pwrok_en(),
                        )
                        .field("pwrok_signal_delay", &self.pwrok_signal_delay())
                        .field(
                            "shutdown_duration_setting",
                            &self.shutdown_duration_setting(),
                        )
                        .finish()
                }
            }
            impl core::ops::BitAnd for PekSettings {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for PekSettings {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for PekSettings {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for PekSettings {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for PekSettings {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for PekSettings {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for PekSettings {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///DCDC working frequency setting.
            pub struct DcdcFrequency {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DcdcFrequency {}
            #[automatically_derived]
            impl ::core::clone::Clone for DcdcFrequency {
                #[inline]
                fn clone(&self) -> DcdcFrequency {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DcdcFrequency {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DcdcFrequency {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DcdcFrequency {
                #[inline]
                fn eq(&self, other: &DcdcFrequency) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DcdcFrequency {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DcdcFrequency {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DcdcFrequency {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DcdcFrequency> for [u8; 1] {
                fn from(val: DcdcFrequency) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DcdcFrequency {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DcdcFrequency").finish()
                }
            }
            impl core::ops::BitAnd for DcdcFrequency {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DcdcFrequency {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DcdcFrequency {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DcdcFrequency {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DcdcFrequency {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DcdcFrequency {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DcdcFrequency {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Battery charge low temperature threshold.
            pub struct BatteryChargeLowTemp {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BatteryChargeLowTemp {}
            #[automatically_derived]
            impl ::core::clone::Clone for BatteryChargeLowTemp {
                #[inline]
                fn clone(&self) -> BatteryChargeLowTemp {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BatteryChargeLowTemp {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BatteryChargeLowTemp {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BatteryChargeLowTemp {
                #[inline]
                fn eq(&self, other: &BatteryChargeLowTemp) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for BatteryChargeLowTemp {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl BatteryChargeLowTemp {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for BatteryChargeLowTemp {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<BatteryChargeLowTemp> for [u8; 1] {
                fn from(val: BatteryChargeLowTemp) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for BatteryChargeLowTemp {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("BatteryChargeLowTemp").finish()
                }
            }
            impl core::ops::BitAnd for BatteryChargeLowTemp {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for BatteryChargeLowTemp {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for BatteryChargeLowTemp {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for BatteryChargeLowTemp {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for BatteryChargeLowTemp {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for BatteryChargeLowTemp {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for BatteryChargeLowTemp {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Battery charge high temperature threshold.
            pub struct BatteryChargeHighTemp {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BatteryChargeHighTemp {}
            #[automatically_derived]
            impl ::core::clone::Clone for BatteryChargeHighTemp {
                #[inline]
                fn clone(&self) -> BatteryChargeHighTemp {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BatteryChargeHighTemp {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BatteryChargeHighTemp {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BatteryChargeHighTemp {
                #[inline]
                fn eq(&self, other: &BatteryChargeHighTemp) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for BatteryChargeHighTemp {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl BatteryChargeHighTemp {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for BatteryChargeHighTemp {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<BatteryChargeHighTemp> for [u8; 1] {
                fn from(val: BatteryChargeHighTemp) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for BatteryChargeHighTemp {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("BatteryChargeHighTemp").finish()
                }
            }
            impl core::ops::BitAnd for BatteryChargeHighTemp {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for BatteryChargeHighTemp {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for BatteryChargeHighTemp {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for BatteryChargeHighTemp {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for BatteryChargeHighTemp {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for BatteryChargeHighTemp {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for BatteryChargeHighTemp {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///APS low power level 1 setting.
            pub struct ApsLowPower1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ApsLowPower1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for ApsLowPower1 {
                #[inline]
                fn clone(&self) -> ApsLowPower1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ApsLowPower1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ApsLowPower1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ApsLowPower1 {
                #[inline]
                fn eq(&self, other: &ApsLowPower1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ApsLowPower1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ApsLowPower1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for ApsLowPower1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ApsLowPower1> for [u8; 1] {
                fn from(val: ApsLowPower1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ApsLowPower1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ApsLowPower1").finish()
                }
            }
            impl core::ops::BitAnd for ApsLowPower1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ApsLowPower1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ApsLowPower1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ApsLowPower1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ApsLowPower1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ApsLowPower1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ApsLowPower1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///APS low power level 2 setting.
            pub struct ApsLowPower2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ApsLowPower2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for ApsLowPower2 {
                #[inline]
                fn clone(&self) -> ApsLowPower2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ApsLowPower2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ApsLowPower2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ApsLowPower2 {
                #[inline]
                fn eq(&self, other: &ApsLowPower2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ApsLowPower2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ApsLowPower2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for ApsLowPower2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<ApsLowPower2> for [u8; 1] {
                fn from(val: ApsLowPower2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ApsLowPower2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ApsLowPower2").finish()
                }
            }
            impl core::ops::BitAnd for ApsLowPower2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ApsLowPower2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ApsLowPower2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ApsLowPower2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ApsLowPower2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ApsLowPower2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ApsLowPower2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Battery discharge low temperature threshold.
            pub struct BatteryDischargeLowTemp {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BatteryDischargeLowTemp {}
            #[automatically_derived]
            impl ::core::clone::Clone for BatteryDischargeLowTemp {
                #[inline]
                fn clone(&self) -> BatteryDischargeLowTemp {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BatteryDischargeLowTemp {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BatteryDischargeLowTemp {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BatteryDischargeLowTemp {
                #[inline]
                fn eq(&self, other: &BatteryDischargeLowTemp) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for BatteryDischargeLowTemp {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl BatteryDischargeLowTemp {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for BatteryDischargeLowTemp {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<BatteryDischargeLowTemp> for [u8; 1] {
                fn from(val: BatteryDischargeLowTemp) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for BatteryDischargeLowTemp {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("BatteryDischargeLowTemp").finish()
                }
            }
            impl core::ops::BitAnd for BatteryDischargeLowTemp {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for BatteryDischargeLowTemp {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for BatteryDischargeLowTemp {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for BatteryDischargeLowTemp {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for BatteryDischargeLowTemp {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for BatteryDischargeLowTemp {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for BatteryDischargeLowTemp {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Battery discharge high temperature threshold.
            pub struct BatteryDischargeHighTemp {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BatteryDischargeHighTemp {}
            #[automatically_derived]
            impl ::core::clone::Clone for BatteryDischargeHighTemp {
                #[inline]
                fn clone(&self) -> BatteryDischargeHighTemp {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BatteryDischargeHighTemp {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BatteryDischargeHighTemp {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BatteryDischargeHighTemp {
                #[inline]
                fn eq(&self, other: &BatteryDischargeHighTemp) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for BatteryDischargeHighTemp {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl BatteryDischargeHighTemp {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for BatteryDischargeHighTemp {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<BatteryDischargeHighTemp> for [u8; 1] {
                fn from(val: BatteryDischargeHighTemp) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for BatteryDischargeHighTemp {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("BatteryDischargeHighTemp").finish()
                }
            }
            impl core::ops::BitAnd for BatteryDischargeHighTemp {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for BatteryDischargeHighTemp {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for BatteryDischargeHighTemp {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for BatteryDischargeHighTemp {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for BatteryDischargeHighTemp {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for BatteryDischargeHighTemp {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for BatteryDischargeHighTemp {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///DCDC working mode control (Auto/PWM).
            pub struct DcdcMode {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DcdcMode {}
            #[automatically_derived]
            impl ::core::clone::Clone for DcdcMode {
                #[inline]
                fn clone(&self) -> DcdcMode {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DcdcMode {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DcdcMode {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DcdcMode {
                #[inline]
                fn eq(&self, other: &DcdcMode) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DcdcMode {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DcdcMode {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for DcdcMode {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<DcdcMode> for [u8; 1] {
                fn from(val: DcdcMode) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DcdcMode {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DcdcMode").finish()
                }
            }
            impl core::ops::BitAnd for DcdcMode {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DcdcMode {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DcdcMode {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DcdcMode {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DcdcMode {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DcdcMode {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DcdcMode {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///ADC enable control 1.
            pub struct AdcEnable1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for AdcEnable1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for AdcEnable1 {
                #[inline]
                fn clone(&self) -> AdcEnable1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for AdcEnable1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AdcEnable1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for AdcEnable1 {
                #[inline]
                fn eq(&self, other: &AdcEnable1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for AdcEnable1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl AdcEnable1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `battery_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn battery_voltage_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `battery_current_adc_enable` field of the register.
                ///
                ///
                pub fn battery_current_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `acin_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn acin_voltage_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Read the `acin_current_adc_enable` field of the register.
                ///
                ///
                pub fn acin_current_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 4)
                    };
                    raw > 0
                }
                ///Read the `vbus_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn vbus_voltage_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 5)
                    };
                    raw > 0
                }
                ///Read the `vbus_current_adc_enable` field of the register.
                ///
                ///
                pub fn vbus_current_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 6)
                    };
                    raw > 0
                }
                ///Read the `aps_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn aps_voltage_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 6, 7)
                    };
                    raw > 0
                }
                ///Read the `ts_pin_adc_enable` field of the register.
                ///
                ///
                pub fn ts_pin_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 7, 8)
                    };
                    raw > 0
                }
                ///Write the `battery_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn set_battery_voltage_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `battery_current_adc_enable` field of the register.
                ///
                ///
                pub fn set_battery_current_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `acin_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn set_acin_voltage_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
                ///Write the `acin_current_adc_enable` field of the register.
                ///
                ///
                pub fn set_acin_current_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 4, &mut self.bits)
                    };
                }
                ///Write the `vbus_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn set_vbus_voltage_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 5, &mut self.bits)
                    };
                }
                ///Write the `vbus_current_adc_enable` field of the register.
                ///
                ///
                pub fn set_vbus_current_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 6, &mut self.bits)
                    };
                }
                ///Write the `aps_voltage_adc_enable` field of the register.
                ///
                ///
                pub fn set_aps_voltage_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 6, 7, &mut self.bits)
                    };
                }
                ///Write the `ts_pin_adc_enable` field of the register.
                ///
                ///
                pub fn set_ts_pin_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 7, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for AdcEnable1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<AdcEnable1> for [u8; 1] {
                fn from(val: AdcEnable1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for AdcEnable1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("AdcEnable1")
                        .field(
                            "battery_voltage_adc_enable",
                            &self.battery_voltage_adc_enable(),
                        )
                        .field(
                            "battery_current_adc_enable",
                            &self.battery_current_adc_enable(),
                        )
                        .field(
                            "acin_voltage_adc_enable",
                            &self.acin_voltage_adc_enable(),
                        )
                        .field(
                            "acin_current_adc_enable",
                            &self.acin_current_adc_enable(),
                        )
                        .field(
                            "vbus_voltage_adc_enable",
                            &self.vbus_voltage_adc_enable(),
                        )
                        .field(
                            "vbus_current_adc_enable",
                            &self.vbus_current_adc_enable(),
                        )
                        .field("aps_voltage_adc_enable", &self.aps_voltage_adc_enable())
                        .field("ts_pin_adc_enable", &self.ts_pin_adc_enable())
                        .finish()
                }
            }
            impl core::ops::BitAnd for AdcEnable1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for AdcEnable1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for AdcEnable1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for AdcEnable1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for AdcEnable1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for AdcEnable1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for AdcEnable1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///ADC enable control 2 (GPIO ADCs, internal temp).
            pub struct AdcEnable2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for AdcEnable2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for AdcEnable2 {
                #[inline]
                fn clone(&self) -> AdcEnable2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for AdcEnable2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AdcEnable2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for AdcEnable2 {
                #[inline]
                fn eq(&self, other: &AdcEnable2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for AdcEnable2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl AdcEnable2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `gpio_0_adc_enable` field of the register.
                ///
                ///
                pub fn gpio_0_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `gpio_1_adc_enable` field of the register.
                ///
                ///
                pub fn gpio_1_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `gpio_2_adc_enable` field of the register.
                ///
                ///
                pub fn gpio_2_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Read the `gpio_3_adc_enable` field of the register.
                ///
                ///
                pub fn gpio_3_adc_enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 4)
                    };
                    raw > 0
                }
                ///Write the `gpio_0_adc_enable` field of the register.
                ///
                ///
                pub fn set_gpio_0_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `gpio_1_adc_enable` field of the register.
                ///
                ///
                pub fn set_gpio_1_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `gpio_2_adc_enable` field of the register.
                ///
                ///
                pub fn set_gpio_2_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
                ///Write the `gpio_3_adc_enable` field of the register.
                ///
                ///
                pub fn set_gpio_3_adc_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 4, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for AdcEnable2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<AdcEnable2> for [u8; 1] {
                fn from(val: AdcEnable2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for AdcEnable2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("AdcEnable2")
                        .field("gpio_0_adc_enable", &self.gpio_0_adc_enable())
                        .field("gpio_1_adc_enable", &self.gpio_1_adc_enable())
                        .field("gpio_2_adc_enable", &self.gpio_2_adc_enable())
                        .field("gpio_3_adc_enable", &self.gpio_3_adc_enable())
                        .finish()
                }
            }
            impl core::ops::BitAnd for AdcEnable2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for AdcEnable2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for AdcEnable2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for AdcEnable2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for AdcEnable2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for AdcEnable2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for AdcEnable2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///ADC sample rate, TS pin control.
            pub struct AdcRateTsPin {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for AdcRateTsPin {}
            #[automatically_derived]
            impl ::core::clone::Clone for AdcRateTsPin {
                #[inline]
                fn clone(&self) -> AdcRateTsPin {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for AdcRateTsPin {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AdcRateTsPin {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for AdcRateTsPin {
                #[inline]
                fn eq(&self, other: &AdcRateTsPin) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for AdcRateTsPin {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl AdcRateTsPin {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for AdcRateTsPin {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<AdcRateTsPin> for [u8; 1] {
                fn from(val: AdcRateTsPin) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for AdcRateTsPin {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("AdcRateTsPin").finish()
                }
            }
            impl core::ops::BitAnd for AdcRateTsPin {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for AdcRateTsPin {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for AdcRateTsPin {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for AdcRateTsPin {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for AdcRateTsPin {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for AdcRateTsPin {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for AdcRateTsPin {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///GPIO0-3 ADC input range.
            pub struct Gpio30InputRange {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio30InputRange {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio30InputRange {
                #[inline]
                fn clone(&self) -> Gpio30InputRange {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio30InputRange {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio30InputRange {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio30InputRange {
                #[inline]
                fn eq(&self, other: &Gpio30InputRange) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio30InputRange {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio30InputRange {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Gpio30InputRange {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio30InputRange> for [u8; 1] {
                fn from(val: Gpio30InputRange) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio30InputRange {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio30InputRange").finish()
                }
            }
            impl core::ops::BitAnd for Gpio30InputRange {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio30InputRange {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio30InputRange {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio30InputRange {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio30InputRange {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio30InputRange {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio30InputRange {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///GPIO0 ADC IRQ rising edge threshold.
            pub struct Gpio0AdcIrqRising {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio0AdcIrqRising {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio0AdcIrqRising {
                #[inline]
                fn clone(&self) -> Gpio0AdcIrqRising {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio0AdcIrqRising {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio0AdcIrqRising {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio0AdcIrqRising {
                #[inline]
                fn eq(&self, other: &Gpio0AdcIrqRising) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio0AdcIrqRising {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio0AdcIrqRising {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Gpio0AdcIrqRising {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio0AdcIrqRising> for [u8; 1] {
                fn from(val: Gpio0AdcIrqRising) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio0AdcIrqRising {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio0AdcIrqRising").finish()
                }
            }
            impl core::ops::BitAnd for Gpio0AdcIrqRising {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio0AdcIrqRising {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio0AdcIrqRising {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio0AdcIrqRising {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio0AdcIrqRising {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio0AdcIrqRising {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio0AdcIrqRising {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///GPIO0 ADC IRQ falling edge threshold.
            pub struct Gpio0AdcIrqFalling {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio0AdcIrqFalling {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio0AdcIrqFalling {
                #[inline]
                fn clone(&self) -> Gpio0AdcIrqFalling {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio0AdcIrqFalling {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio0AdcIrqFalling {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio0AdcIrqFalling {
                #[inline]
                fn eq(&self, other: &Gpio0AdcIrqFalling) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio0AdcIrqFalling {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio0AdcIrqFalling {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Gpio0AdcIrqFalling {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio0AdcIrqFalling> for [u8; 1] {
                fn from(val: Gpio0AdcIrqFalling) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio0AdcIrqFalling {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio0AdcIrqFalling").finish()
                }
            }
            impl core::ops::BitAnd for Gpio0AdcIrqFalling {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio0AdcIrqFalling {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio0AdcIrqFalling {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio0AdcIrqFalling {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio0AdcIrqFalling {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio0AdcIrqFalling {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio0AdcIrqFalling {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Timer control.
            pub struct TimerControl {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TimerControl {}
            #[automatically_derived]
            impl ::core::clone::Clone for TimerControl {
                #[inline]
                fn clone(&self) -> TimerControl {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for TimerControl {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TimerControl {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TimerControl {
                #[inline]
                fn eq(&self, other: &TimerControl) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for TimerControl {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl TimerControl {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for TimerControl {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<TimerControl> for [u8; 1] {
                fn from(val: TimerControl) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for TimerControl {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("TimerControl").finish()
                }
            }
            impl core::ops::BitAnd for TimerControl {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for TimerControl {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for TimerControl {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for TimerControl {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for TimerControl {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for TimerControl {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for TimerControl {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///VBUS monitor, salkl aralk ayar.
            pub struct VbusMonitor {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for VbusMonitor {}
            #[automatically_derived]
            impl ::core::clone::Clone for VbusMonitor {
                #[inline]
                fn clone(&self) -> VbusMonitor {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for VbusMonitor {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VbusMonitor {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for VbusMonitor {
                #[inline]
                fn eq(&self, other: &VbusMonitor) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for VbusMonitor {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl VbusMonitor {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for VbusMonitor {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<VbusMonitor> for [u8; 1] {
                fn from(val: VbusMonitor) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for VbusMonitor {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("VbusMonitor").finish()
                }
            }
            impl core::ops::BitAnd for VbusMonitor {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for VbusMonitor {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for VbusMonitor {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for VbusMonitor {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for VbusMonitor {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for VbusMonitor {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for VbusMonitor {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Over temperature shutdown control.
            pub struct TempShutdownControl {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TempShutdownControl {}
            #[automatically_derived]
            impl ::core::clone::Clone for TempShutdownControl {
                #[inline]
                fn clone(&self) -> TempShutdownControl {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for TempShutdownControl {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TempShutdownControl {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TempShutdownControl {
                #[inline]
                fn eq(&self, other: &TempShutdownControl) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for TempShutdownControl {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl TempShutdownControl {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for TempShutdownControl {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<TempShutdownControl> for [u8; 1] {
                fn from(val: TempShutdownControl) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for TempShutdownControl {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("TempShutdownControl").finish()
                }
            }
            impl core::ops::BitAnd for TempShutdownControl {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for TempShutdownControl {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for TempShutdownControl {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for TempShutdownControl {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for TempShutdownControl {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for TempShutdownControl {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for TempShutdownControl {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio0Control {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio0Control {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio0Control {
                #[inline]
                fn clone(&self) -> Gpio0Control {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio0Control {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio0Control {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio0Control {
                #[inline]
                fn eq(&self, other: &Gpio0Control) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio0Control {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio0Control {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `mode` field of the register.
                ///
                ///GPIO0 func: 000 NMOS-OD, 001 Input, 010 LDO(LDOIO0), 100 ADC, 101 Low, 11x Float
                pub fn mode(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 8)
                    };
                    raw
                }
                ///Write the `mode` field of the register.
                ///
                ///GPIO0 func: 000 NMOS-OD, 001 Input, 010 LDO(LDOIO0), 100 ADC, 101 Low, 11x Float
                pub fn set_mode(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Gpio0Control {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio0Control> for [u8; 1] {
                fn from(val: Gpio0Control) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio0Control {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio0Control").field("mode", &self.mode()).finish()
                }
            }
            impl core::ops::BitAnd for Gpio0Control {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio0Control {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio0Control {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio0Control {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio0Control {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio0Control {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio0Control {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///GPIO0 LDO (LDOIO0) output voltage setting.
            pub struct Gpio0Ldoio0Voltage {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio0Ldoio0Voltage {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio0Ldoio0Voltage {
                #[inline]
                fn clone(&self) -> Gpio0Ldoio0Voltage {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio0Ldoio0Voltage {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio0Ldoio0Voltage {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio0Ldoio0Voltage {
                #[inline]
                fn eq(&self, other: &Gpio0Ldoio0Voltage) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio0Ldoio0Voltage {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio0Ldoio0Voltage {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `voltage_setting` field of the register.
                ///
                ///
                pub fn voltage_setting(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 4)
                    };
                    raw
                }
                ///Write the `voltage_setting` field of the register.
                ///
                ///
                pub fn set_voltage_setting(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 4, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Gpio0Ldoio0Voltage {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio0Ldoio0Voltage> for [u8; 1] {
                fn from(val: Gpio0Ldoio0Voltage) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio0Ldoio0Voltage {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio0Ldoio0Voltage")
                        .field("voltage_setting", &self.voltage_setting())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Gpio0Ldoio0Voltage {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio0Ldoio0Voltage {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio0Ldoio0Voltage {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio0Ldoio0Voltage {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio0Ldoio0Voltage {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio0Ldoio0Voltage {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio0Ldoio0Voltage {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio1Control {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio1Control {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio1Control {
                #[inline]
                fn clone(&self) -> Gpio1Control {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio1Control {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio1Control {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio1Control {
                #[inline]
                fn eq(&self, other: &Gpio1Control) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio1Control {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio1Control {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `mode` field of the register.
                ///
                ///GPIO1 func: 000 NMOS-OD, 001 Input, 010 PWM1, 100 ADC, 101 Low (CHGLED), 11x Float
                pub fn mode(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 8)
                    };
                    raw
                }
                ///Write the `mode` field of the register.
                ///
                ///GPIO1 func: 000 NMOS-OD, 001 Input, 010 PWM1, 100 ADC, 101 Low (CHGLED), 11x Float
                pub fn set_mode(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Gpio1Control {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio1Control> for [u8; 1] {
                fn from(val: Gpio1Control) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio1Control {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio1Control").field("mode", &self.mode()).finish()
                }
            }
            impl core::ops::BitAnd for Gpio1Control {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio1Control {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio1Control {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio1Control {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio1Control {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio1Control {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio1Control {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio2Control {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio2Control {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio2Control {
                #[inline]
                fn clone(&self) -> Gpio2Control {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio2Control {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio2Control {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio2Control {
                #[inline]
                fn eq(&self, other: &Gpio2Control) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio2Control {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio2Control {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `mode` field of the register.
                ///
                ///GPIO2 func: 000 NMOS-OD, 001 Input, 010 PWM2, 100 ADC, 101 Low, 11x Float
                pub fn mode(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 8)
                    };
                    raw
                }
                ///Write the `mode` field of the register.
                ///
                ///GPIO2 func: 000 NMOS-OD, 001 Input, 010 PWM2, 100 ADC, 101 Low, 11x Float
                pub fn set_mode(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Gpio2Control {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio2Control> for [u8; 1] {
                fn from(val: Gpio2Control) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio2Control {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio2Control").field("mode", &self.mode()).finish()
                }
            }
            impl core::ops::BitAnd for Gpio2Control {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio2Control {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio2Control {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio2Control {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio2Control {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio2Control {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio2Control {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio20SignalStatus {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio20SignalStatus {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio20SignalStatus {
                #[inline]
                fn clone(&self) -> Gpio20SignalStatus {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio20SignalStatus {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio20SignalStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio20SignalStatus {
                #[inline]
                fn eq(&self, other: &Gpio20SignalStatus) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio20SignalStatus {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio20SignalStatus {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `gpio_2_out_level` field of the register.
                ///
                ///
                pub fn gpio_2_out_level(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 6)
                    };
                    raw > 0
                }
                ///Read the `gpio_1_out_level` field of the register.
                ///
                ///
                pub fn gpio_1_out_level(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 6, 7)
                    };
                    raw > 0
                }
                ///Read the `gpio_0_out_level` field of the register.
                ///
                ///
                pub fn gpio_0_out_level(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 7, 8)
                    };
                    raw > 0
                }
                ///Write the `gpio_2_out_level` field of the register.
                ///
                ///
                pub fn set_gpio_2_out_level(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 6, &mut self.bits)
                    };
                }
                ///Write the `gpio_1_out_level` field of the register.
                ///
                ///
                pub fn set_gpio_1_out_level(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 6, 7, &mut self.bits)
                    };
                }
                ///Write the `gpio_0_out_level` field of the register.
                ///
                ///
                pub fn set_gpio_0_out_level(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 7, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Gpio20SignalStatus {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio20SignalStatus> for [u8; 1] {
                fn from(val: Gpio20SignalStatus) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio20SignalStatus {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio20SignalStatus")
                        .field("gpio_2_out_level", &self.gpio_2_out_level())
                        .field("gpio_1_out_level", &self.gpio_1_out_level())
                        .field("gpio_0_out_level", &self.gpio_0_out_level())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Gpio20SignalStatus {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio20SignalStatus {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio20SignalStatus {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio20SignalStatus {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio20SignalStatus {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio20SignalStatus {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio20SignalStatus {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///GPIO3/4 function control.
            pub struct Gpio43FunctionControl {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio43FunctionControl {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio43FunctionControl {
                #[inline]
                fn clone(&self) -> Gpio43FunctionControl {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio43FunctionControl {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio43FunctionControl {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio43FunctionControl {
                #[inline]
                fn eq(&self, other: &Gpio43FunctionControl) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio43FunctionControl {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio43FunctionControl {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `enable_gpio_34_control` field of the register.
                ///
                ///
                pub fn enable_gpio_34_control(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `gpio_4_mode` field of the register.
                ///
                ///GPIO4 func (bits 3-2): 00 Ext CHG, 01 NMOS-OD, 10 Input
                pub fn gpio_4_mode(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 5)
                    };
                    raw
                }
                ///Read the `gpio_3_mode` field of the register.
                ///
                ///GPIO3 func (bits 1-0): 00 Ext CHG, 01 NMOS-OD, 10 Input, 11 ADC
                pub fn gpio_3_mode(&self) -> u8 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 7)
                    };
                    raw
                }
                ///Write the `enable_gpio_34_control` field of the register.
                ///
                ///
                pub fn set_enable_gpio_34_control(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `gpio_4_mode` field of the register.
                ///
                ///GPIO4 func (bits 3-2): 00 Ext CHG, 01 NMOS-OD, 10 Input
                pub fn set_gpio_4_mode(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 5, &mut self.bits)
                    };
                }
                ///Write the `gpio_3_mode` field of the register.
                ///
                ///GPIO3 func (bits 1-0): 00 Ext CHG, 01 NMOS-OD, 10 Input, 11 ADC
                pub fn set_gpio_3_mode(&mut self, value: u8) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 7, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Gpio43FunctionControl {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio43FunctionControl> for [u8; 1] {
                fn from(val: Gpio43FunctionControl) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio43FunctionControl {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio43FunctionControl")
                        .field("enable_gpio_34_control", &self.enable_gpio_34_control())
                        .field("gpio_4_mode", &self.gpio_4_mode())
                        .field("gpio_3_mode", &self.gpio_3_mode())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Gpio43FunctionControl {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio43FunctionControl {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio43FunctionControl {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio43FunctionControl {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio43FunctionControl {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio43FunctionControl {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio43FunctionControl {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///GPIO3/4 output level control and input status.
            pub struct Gpio43SignalStatus {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio43SignalStatus {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio43SignalStatus {
                #[inline]
                fn clone(&self) -> Gpio43SignalStatus {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio43SignalStatus {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio43SignalStatus {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio43SignalStatus {
                #[inline]
                fn eq(&self, other: &Gpio43SignalStatus) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio43SignalStatus {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio43SignalStatus {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `gpio_4_out_level` field of the register.
                ///
                ///
                pub fn gpio_4_out_level(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 6, 7)
                    };
                    raw > 0
                }
                ///Read the `gpio_3_out_level` field of the register.
                ///
                ///
                pub fn gpio_3_out_level(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 7, 8)
                    };
                    raw > 0
                }
                ///Write the `gpio_4_out_level` field of the register.
                ///
                ///
                pub fn set_gpio_4_out_level(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 6, 7, &mut self.bits)
                    };
                }
                ///Write the `gpio_3_out_level` field of the register.
                ///
                ///
                pub fn set_gpio_3_out_level(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 7, 8, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for Gpio43SignalStatus {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio43SignalStatus> for [u8; 1] {
                fn from(val: Gpio43SignalStatus) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio43SignalStatus {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio43SignalStatus")
                        .field("gpio_4_out_level", &self.gpio_4_out_level())
                        .field("gpio_3_out_level", &self.gpio_3_out_level())
                        .finish()
                }
            }
            impl core::ops::BitAnd for Gpio43SignalStatus {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio43SignalStatus {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio43SignalStatus {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio43SignalStatus {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio43SignalStatus {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio43SignalStatus {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio43SignalStatus {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///GPIO0-2 pulldown resistor control.
            pub struct Gpio20PulldownControl {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio20PulldownControl {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio20PulldownControl {
                #[inline]
                fn clone(&self) -> Gpio20PulldownControl {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio20PulldownControl {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio20PulldownControl {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio20PulldownControl {
                #[inline]
                fn eq(&self, other: &Gpio20PulldownControl) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio20PulldownControl {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio20PulldownControl {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Gpio20PulldownControl {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio20PulldownControl> for [u8; 1] {
                fn from(val: Gpio20PulldownControl) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio20PulldownControl {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio20PulldownControl").finish()
                }
            }
            impl core::ops::BitAnd for Gpio20PulldownControl {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio20PulldownControl {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio20PulldownControl {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio20PulldownControl {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio20PulldownControl {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio20PulldownControl {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio20PulldownControl {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///PWM1 frequency setting.
            pub struct Pwm1Frequency {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Pwm1Frequency {}
            #[automatically_derived]
            impl ::core::clone::Clone for Pwm1Frequency {
                #[inline]
                fn clone(&self) -> Pwm1Frequency {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Pwm1Frequency {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Pwm1Frequency {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Pwm1Frequency {
                #[inline]
                fn eq(&self, other: &Pwm1Frequency) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Pwm1Frequency {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Pwm1Frequency {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Pwm1Frequency {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Pwm1Frequency> for [u8; 1] {
                fn from(val: Pwm1Frequency) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Pwm1Frequency {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Pwm1Frequency").finish()
                }
            }
            impl core::ops::BitAnd for Pwm1Frequency {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Pwm1Frequency {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Pwm1Frequency {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Pwm1Frequency {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Pwm1Frequency {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Pwm1Frequency {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Pwm1Frequency {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///PWM1 duty cycle MSBs.
            pub struct Pwm1DutyCycle1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Pwm1DutyCycle1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for Pwm1DutyCycle1 {
                #[inline]
                fn clone(&self) -> Pwm1DutyCycle1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Pwm1DutyCycle1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Pwm1DutyCycle1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Pwm1DutyCycle1 {
                #[inline]
                fn eq(&self, other: &Pwm1DutyCycle1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Pwm1DutyCycle1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Pwm1DutyCycle1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Pwm1DutyCycle1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Pwm1DutyCycle1> for [u8; 1] {
                fn from(val: Pwm1DutyCycle1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Pwm1DutyCycle1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Pwm1DutyCycle1").finish()
                }
            }
            impl core::ops::BitAnd for Pwm1DutyCycle1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Pwm1DutyCycle1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Pwm1DutyCycle1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Pwm1DutyCycle1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Pwm1DutyCycle1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Pwm1DutyCycle1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Pwm1DutyCycle1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///PWM1 duty cycle LSBs.
            pub struct Pwm1DutyCycle2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Pwm1DutyCycle2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for Pwm1DutyCycle2 {
                #[inline]
                fn clone(&self) -> Pwm1DutyCycle2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Pwm1DutyCycle2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Pwm1DutyCycle2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Pwm1DutyCycle2 {
                #[inline]
                fn eq(&self, other: &Pwm1DutyCycle2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Pwm1DutyCycle2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Pwm1DutyCycle2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Pwm1DutyCycle2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Pwm1DutyCycle2> for [u8; 1] {
                fn from(val: Pwm1DutyCycle2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Pwm1DutyCycle2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Pwm1DutyCycle2").finish()
                }
            }
            impl core::ops::BitAnd for Pwm1DutyCycle2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Pwm1DutyCycle2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Pwm1DutyCycle2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Pwm1DutyCycle2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Pwm1DutyCycle2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Pwm1DutyCycle2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Pwm1DutyCycle2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///PWM2 frequency setting.
            pub struct Pwm2Frequency {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Pwm2Frequency {}
            #[automatically_derived]
            impl ::core::clone::Clone for Pwm2Frequency {
                #[inline]
                fn clone(&self) -> Pwm2Frequency {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Pwm2Frequency {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Pwm2Frequency {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Pwm2Frequency {
                #[inline]
                fn eq(&self, other: &Pwm2Frequency) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Pwm2Frequency {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Pwm2Frequency {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Pwm2Frequency {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Pwm2Frequency> for [u8; 1] {
                fn from(val: Pwm2Frequency) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Pwm2Frequency {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Pwm2Frequency").finish()
                }
            }
            impl core::ops::BitAnd for Pwm2Frequency {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Pwm2Frequency {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Pwm2Frequency {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Pwm2Frequency {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Pwm2Frequency {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Pwm2Frequency {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Pwm2Frequency {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///PWM2 duty cycle MSBs.
            pub struct Pwm2DutyCycle1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Pwm2DutyCycle1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for Pwm2DutyCycle1 {
                #[inline]
                fn clone(&self) -> Pwm2DutyCycle1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Pwm2DutyCycle1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Pwm2DutyCycle1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Pwm2DutyCycle1 {
                #[inline]
                fn eq(&self, other: &Pwm2DutyCycle1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Pwm2DutyCycle1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Pwm2DutyCycle1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Pwm2DutyCycle1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Pwm2DutyCycle1> for [u8; 1] {
                fn from(val: Pwm2DutyCycle1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Pwm2DutyCycle1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Pwm2DutyCycle1").finish()
                }
            }
            impl core::ops::BitAnd for Pwm2DutyCycle1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Pwm2DutyCycle1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Pwm2DutyCycle1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Pwm2DutyCycle1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Pwm2DutyCycle1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Pwm2DutyCycle1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Pwm2DutyCycle1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///PWM2 duty cycle LSBs.
            pub struct Pwm2DutyCycle2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Pwm2DutyCycle2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for Pwm2DutyCycle2 {
                #[inline]
                fn clone(&self) -> Pwm2DutyCycle2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Pwm2DutyCycle2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Pwm2DutyCycle2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Pwm2DutyCycle2 {
                #[inline]
                fn eq(&self, other: &Pwm2DutyCycle2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Pwm2DutyCycle2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Pwm2DutyCycle2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for Pwm2DutyCycle2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<Pwm2DutyCycle2> for [u8; 1] {
                fn from(val: Pwm2DutyCycle2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Pwm2DutyCycle2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Pwm2DutyCycle2").finish()
                }
            }
            impl core::ops::BitAnd for Pwm2DutyCycle2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Pwm2DutyCycle2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Pwm2DutyCycle2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Pwm2DutyCycle2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Pwm2DutyCycle2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Pwm2DutyCycle2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Pwm2DutyCycle2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///N_RSTO (Reset Out) / GPIO5 control.
            pub struct NRstoGpio5Control {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for NRstoGpio5Control {}
            #[automatically_derived]
            impl ::core::clone::Clone for NRstoGpio5Control {
                #[inline]
                fn clone(&self) -> NRstoGpio5Control {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for NRstoGpio5Control {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for NRstoGpio5Control {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for NRstoGpio5Control {
                #[inline]
                fn eq(&self, other: &NRstoGpio5Control) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for NRstoGpio5Control {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl NRstoGpio5Control {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for NRstoGpio5Control {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<NRstoGpio5Control> for [u8; 1] {
                fn from(val: NRstoGpio5Control) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for NRstoGpio5Control {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("NRstoGpio5Control").finish()
                }
            }
            impl core::ops::BitAnd for NRstoGpio5Control {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for NRstoGpio5Control {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for NRstoGpio5Control {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for NRstoGpio5Control {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for NRstoGpio5Control {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for NRstoGpio5Control {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for NRstoGpio5Control {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Enable Control 1.
            pub struct EnableControl1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EnableControl1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for EnableControl1 {
                #[inline]
                fn clone(&self) -> EnableControl1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for EnableControl1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EnableControl1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for EnableControl1 {
                #[inline]
                fn eq(&self, other: &EnableControl1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for EnableControl1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl EnableControl1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `acin_over_voltage_irq_en` field of the register.
                ///
                ///
                pub fn acin_over_voltage_irq_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `acin_connect_irq_en` field of the register.
                ///
                ///
                pub fn acin_connect_irq_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `acin_disconnect_irq_en` field of the register.
                ///
                ///
                pub fn acin_disconnect_irq_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Read the `vbus_over_voltage_irq_en` field of the register.
                ///
                ///
                pub fn vbus_over_voltage_irq_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 3, 4)
                    };
                    raw > 0
                }
                ///Read the `vbus_connect_irq_en` field of the register.
                ///
                ///
                pub fn vbus_connect_irq_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 4, 5)
                    };
                    raw > 0
                }
                ///Read the `vbus_disconnect_irq_en` field of the register.
                ///
                ///
                pub fn vbus_disconnect_irq_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 5, 6)
                    };
                    raw > 0
                }
                ///Read the `vbus_low_voltage_irq_en` field of the register.
                ///
                ///
                pub fn vbus_low_voltage_irq_en(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 6, 7)
                    };
                    raw > 0
                }
                ///Write the `acin_over_voltage_irq_en` field of the register.
                ///
                ///
                pub fn set_acin_over_voltage_irq_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `acin_connect_irq_en` field of the register.
                ///
                ///
                pub fn set_acin_connect_irq_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `acin_disconnect_irq_en` field of the register.
                ///
                ///
                pub fn set_acin_disconnect_irq_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
                ///Write the `vbus_over_voltage_irq_en` field of the register.
                ///
                ///
                pub fn set_vbus_over_voltage_irq_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 3, 4, &mut self.bits)
                    };
                }
                ///Write the `vbus_connect_irq_en` field of the register.
                ///
                ///
                pub fn set_vbus_connect_irq_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 4, 5, &mut self.bits)
                    };
                }
                ///Write the `vbus_disconnect_irq_en` field of the register.
                ///
                ///
                pub fn set_vbus_disconnect_irq_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 5, 6, &mut self.bits)
                    };
                }
                ///Write the `vbus_low_voltage_irq_en` field of the register.
                ///
                ///
                pub fn set_vbus_low_voltage_irq_en(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 6, 7, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for EnableControl1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<EnableControl1> for [u8; 1] {
                fn from(val: EnableControl1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for EnableControl1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("EnableControl1")
                        .field(
                            "acin_over_voltage_irq_en",
                            &self.acin_over_voltage_irq_en(),
                        )
                        .field("acin_connect_irq_en", &self.acin_connect_irq_en())
                        .field("acin_disconnect_irq_en", &self.acin_disconnect_irq_en())
                        .field(
                            "vbus_over_voltage_irq_en",
                            &self.vbus_over_voltage_irq_en(),
                        )
                        .field("vbus_connect_irq_en", &self.vbus_connect_irq_en())
                        .field("vbus_disconnect_irq_en", &self.vbus_disconnect_irq_en())
                        .field(
                            "vbus_low_voltage_irq_en",
                            &self.vbus_low_voltage_irq_en(),
                        )
                        .finish()
                }
            }
            impl core::ops::BitAnd for EnableControl1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for EnableControl1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for EnableControl1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for EnableControl1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for EnableControl1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for EnableControl1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for EnableControl1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Enable Control 2.
            pub struct EnableControl2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EnableControl2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for EnableControl2 {
                #[inline]
                fn clone(&self) -> EnableControl2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for EnableControl2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EnableControl2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for EnableControl2 {
                #[inline]
                fn eq(&self, other: &EnableControl2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for EnableControl2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl EnableControl2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for EnableControl2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<EnableControl2> for [u8; 1] {
                fn from(val: EnableControl2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for EnableControl2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("EnableControl2").finish()
                }
            }
            impl core::ops::BitAnd for EnableControl2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for EnableControl2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for EnableControl2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for EnableControl2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for EnableControl2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for EnableControl2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for EnableControl2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Enable Control 3.
            pub struct EnableControl3 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EnableControl3 {}
            #[automatically_derived]
            impl ::core::clone::Clone for EnableControl3 {
                #[inline]
                fn clone(&self) -> EnableControl3 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for EnableControl3 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EnableControl3 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for EnableControl3 {
                #[inline]
                fn eq(&self, other: &EnableControl3) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for EnableControl3 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl EnableControl3 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for EnableControl3 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<EnableControl3> for [u8; 1] {
                fn from(val: EnableControl3) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for EnableControl3 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("EnableControl3").finish()
                }
            }
            impl core::ops::BitAnd for EnableControl3 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for EnableControl3 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for EnableControl3 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for EnableControl3 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for EnableControl3 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for EnableControl3 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for EnableControl3 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Enable Control 4.
            pub struct EnableControl4 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EnableControl4 {}
            #[automatically_derived]
            impl ::core::clone::Clone for EnableControl4 {
                #[inline]
                fn clone(&self) -> EnableControl4 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for EnableControl4 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EnableControl4 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for EnableControl4 {
                #[inline]
                fn eq(&self, other: &EnableControl4) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for EnableControl4 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl EnableControl4 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for EnableControl4 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<EnableControl4> for [u8; 1] {
                fn from(val: EnableControl4) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for EnableControl4 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("EnableControl4").finish()
                }
            }
            impl core::ops::BitAnd for EnableControl4 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for EnableControl4 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for EnableControl4 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for EnableControl4 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for EnableControl4 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for EnableControl4 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for EnableControl4 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Enable Control 5.
            pub struct EnableControl5 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for EnableControl5 {}
            #[automatically_derived]
            impl ::core::clone::Clone for EnableControl5 {
                #[inline]
                fn clone(&self) -> EnableControl5 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for EnableControl5 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EnableControl5 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for EnableControl5 {
                #[inline]
                fn eq(&self, other: &EnableControl5) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for EnableControl5 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl EnableControl5 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for EnableControl5 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<EnableControl5> for [u8; 1] {
                fn from(val: EnableControl5) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for EnableControl5 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("EnableControl5").finish()
                }
            }
            impl core::ops::BitAnd for EnableControl5 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for EnableControl5 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for EnableControl5 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for EnableControl5 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for EnableControl5 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for EnableControl5 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for EnableControl5 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Status 1 (Write 1 to clear).
            pub struct IrqStatus1 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IrqStatus1 {}
            #[automatically_derived]
            impl ::core::clone::Clone for IrqStatus1 {
                #[inline]
                fn clone(&self) -> IrqStatus1 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for IrqStatus1 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IrqStatus1 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IrqStatus1 {
                #[inline]
                fn eq(&self, other: &IrqStatus1) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for IrqStatus1 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl IrqStatus1 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for IrqStatus1 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<IrqStatus1> for [u8; 1] {
                fn from(val: IrqStatus1) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for IrqStatus1 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("IrqStatus1").finish()
                }
            }
            impl core::ops::BitAnd for IrqStatus1 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for IrqStatus1 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for IrqStatus1 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for IrqStatus1 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for IrqStatus1 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for IrqStatus1 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for IrqStatus1 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Status 2.
            pub struct IrqStatus2 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IrqStatus2 {}
            #[automatically_derived]
            impl ::core::clone::Clone for IrqStatus2 {
                #[inline]
                fn clone(&self) -> IrqStatus2 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for IrqStatus2 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IrqStatus2 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IrqStatus2 {
                #[inline]
                fn eq(&self, other: &IrqStatus2) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for IrqStatus2 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl IrqStatus2 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for IrqStatus2 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<IrqStatus2> for [u8; 1] {
                fn from(val: IrqStatus2) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for IrqStatus2 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("IrqStatus2").finish()
                }
            }
            impl core::ops::BitAnd for IrqStatus2 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for IrqStatus2 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for IrqStatus2 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for IrqStatus2 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for IrqStatus2 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for IrqStatus2 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for IrqStatus2 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Status 3.
            pub struct IrqStatus3 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IrqStatus3 {}
            #[automatically_derived]
            impl ::core::clone::Clone for IrqStatus3 {
                #[inline]
                fn clone(&self) -> IrqStatus3 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for IrqStatus3 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IrqStatus3 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IrqStatus3 {
                #[inline]
                fn eq(&self, other: &IrqStatus3) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for IrqStatus3 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl IrqStatus3 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for IrqStatus3 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<IrqStatus3> for [u8; 1] {
                fn from(val: IrqStatus3) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for IrqStatus3 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("IrqStatus3").finish()
                }
            }
            impl core::ops::BitAnd for IrqStatus3 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for IrqStatus3 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for IrqStatus3 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for IrqStatus3 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for IrqStatus3 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for IrqStatus3 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for IrqStatus3 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Status 4.
            pub struct IrqStatus4 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IrqStatus4 {}
            #[automatically_derived]
            impl ::core::clone::Clone for IrqStatus4 {
                #[inline]
                fn clone(&self) -> IrqStatus4 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for IrqStatus4 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IrqStatus4 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IrqStatus4 {
                #[inline]
                fn eq(&self, other: &IrqStatus4) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for IrqStatus4 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl IrqStatus4 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for IrqStatus4 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<IrqStatus4> for [u8; 1] {
                fn from(val: IrqStatus4) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for IrqStatus4 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("IrqStatus4").finish()
                }
            }
            impl core::ops::BitAnd for IrqStatus4 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for IrqStatus4 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for IrqStatus4 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for IrqStatus4 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for IrqStatus4 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for IrqStatus4 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for IrqStatus4 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Interrupt Status 5.
            pub struct IrqStatus5 {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for IrqStatus5 {}
            #[automatically_derived]
            impl ::core::clone::Clone for IrqStatus5 {
                #[inline]
                fn clone(&self) -> IrqStatus5 {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for IrqStatus5 {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for IrqStatus5 {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for IrqStatus5 {
                #[inline]
                fn eq(&self, other: &IrqStatus5) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for IrqStatus5 {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl IrqStatus5 {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
            }
            impl From<[u8; 1]> for IrqStatus5 {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<IrqStatus5> for [u8; 1] {
                fn from(val: IrqStatus5) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for IrqStatus5 {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("IrqStatus5").finish()
                }
            }
            impl core::ops::BitAnd for IrqStatus5 {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for IrqStatus5 {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for IrqStatus5 {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for IrqStatus5 {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for IrqStatus5 {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for IrqStatus5 {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for IrqStatus5 {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct AcinVoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for AcinVoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for AcinVoltageAdc {
                #[inline]
                fn clone(&self) -> AcinVoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for AcinVoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AcinVoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for AcinVoltageAdc {
                #[inline]
                fn eq(&self, other: &AcinVoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for AcinVoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl AcinVoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for AcinVoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<AcinVoltageAdc> for [u8; 2] {
                fn from(val: AcinVoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for AcinVoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("AcinVoltageAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for AcinVoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for AcinVoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for AcinVoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for AcinVoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for AcinVoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for AcinVoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for AcinVoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct AcinCurrentAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for AcinCurrentAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for AcinCurrentAdc {
                #[inline]
                fn clone(&self) -> AcinCurrentAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for AcinCurrentAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for AcinCurrentAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for AcinCurrentAdc {
                #[inline]
                fn eq(&self, other: &AcinCurrentAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for AcinCurrentAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl AcinCurrentAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for AcinCurrentAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<AcinCurrentAdc> for [u8; 2] {
                fn from(val: AcinCurrentAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for AcinCurrentAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("AcinCurrentAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for AcinCurrentAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for AcinCurrentAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for AcinCurrentAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for AcinCurrentAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for AcinCurrentAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for AcinCurrentAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for AcinCurrentAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct VbusVoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for VbusVoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for VbusVoltageAdc {
                #[inline]
                fn clone(&self) -> VbusVoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for VbusVoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VbusVoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for VbusVoltageAdc {
                #[inline]
                fn eq(&self, other: &VbusVoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for VbusVoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl VbusVoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for VbusVoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<VbusVoltageAdc> for [u8; 2] {
                fn from(val: VbusVoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for VbusVoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("VbusVoltageAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for VbusVoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for VbusVoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for VbusVoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for VbusVoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for VbusVoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for VbusVoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for VbusVoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct VbusCurrentAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for VbusCurrentAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for VbusCurrentAdc {
                #[inline]
                fn clone(&self) -> VbusCurrentAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for VbusCurrentAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for VbusCurrentAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for VbusCurrentAdc {
                #[inline]
                fn eq(&self, other: &VbusCurrentAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for VbusCurrentAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl VbusCurrentAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for VbusCurrentAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<VbusCurrentAdc> for [u8; 2] {
                fn from(val: VbusCurrentAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for VbusCurrentAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("VbusCurrentAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for VbusCurrentAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for VbusCurrentAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for VbusCurrentAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for VbusCurrentAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for VbusCurrentAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for VbusCurrentAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for VbusCurrentAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct InternalTemperatureAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for InternalTemperatureAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for InternalTemperatureAdc {
                #[inline]
                fn clone(&self) -> InternalTemperatureAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for InternalTemperatureAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for InternalTemperatureAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for InternalTemperatureAdc {
                #[inline]
                fn eq(&self, other: &InternalTemperatureAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for InternalTemperatureAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl InternalTemperatureAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for InternalTemperatureAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<InternalTemperatureAdc> for [u8; 2] {
                fn from(val: InternalTemperatureAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for InternalTemperatureAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("InternalTemperatureAdc")
                        .field("raw", &self.raw())
                        .finish()
                }
            }
            impl core::ops::BitAnd for InternalTemperatureAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for InternalTemperatureAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for InternalTemperatureAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for InternalTemperatureAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for InternalTemperatureAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for InternalTemperatureAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for InternalTemperatureAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct TsInputAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for TsInputAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for TsInputAdc {
                #[inline]
                fn clone(&self) -> TsInputAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for TsInputAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for TsInputAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for TsInputAdc {
                #[inline]
                fn eq(&self, other: &TsInputAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for TsInputAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl TsInputAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for TsInputAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<TsInputAdc> for [u8; 2] {
                fn from(val: TsInputAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for TsInputAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("TsInputAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for TsInputAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for TsInputAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for TsInputAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for TsInputAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for TsInputAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for TsInputAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for TsInputAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio0VoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio0VoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio0VoltageAdc {
                #[inline]
                fn clone(&self) -> Gpio0VoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio0VoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio0VoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio0VoltageAdc {
                #[inline]
                fn eq(&self, other: &Gpio0VoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio0VoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio0VoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for Gpio0VoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio0VoltageAdc> for [u8; 2] {
                fn from(val: Gpio0VoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio0VoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio0VoltageAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for Gpio0VoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio0VoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio0VoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio0VoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio0VoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio0VoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio0VoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio1VoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio1VoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio1VoltageAdc {
                #[inline]
                fn clone(&self) -> Gpio1VoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio1VoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio1VoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio1VoltageAdc {
                #[inline]
                fn eq(&self, other: &Gpio1VoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio1VoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio1VoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for Gpio1VoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio1VoltageAdc> for [u8; 2] {
                fn from(val: Gpio1VoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio1VoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio1VoltageAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for Gpio1VoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio1VoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio1VoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio1VoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio1VoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio1VoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio1VoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio2VoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio2VoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio2VoltageAdc {
                #[inline]
                fn clone(&self) -> Gpio2VoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio2VoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio2VoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio2VoltageAdc {
                #[inline]
                fn eq(&self, other: &Gpio2VoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio2VoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio2VoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for Gpio2VoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio2VoltageAdc> for [u8; 2] {
                fn from(val: Gpio2VoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio2VoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio2VoltageAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for Gpio2VoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio2VoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio2VoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio2VoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio2VoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio2VoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio2VoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct Gpio3VoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Gpio3VoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for Gpio3VoltageAdc {
                #[inline]
                fn clone(&self) -> Gpio3VoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for Gpio3VoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Gpio3VoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Gpio3VoltageAdc {
                #[inline]
                fn eq(&self, other: &Gpio3VoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for Gpio3VoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl Gpio3VoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for Gpio3VoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<Gpio3VoltageAdc> for [u8; 2] {
                fn from(val: Gpio3VoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for Gpio3VoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("Gpio3VoltageAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for Gpio3VoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for Gpio3VoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for Gpio3VoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for Gpio3VoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for Gpio3VoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for Gpio3VoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for Gpio3VoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Battery power ADC raw value (23-bit result).
            pub struct BatteryPowerAdc {
                /// The internal bits
                bits: [u8; 3],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BatteryPowerAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for BatteryPowerAdc {
                #[inline]
                fn clone(&self) -> BatteryPowerAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 3]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BatteryPowerAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 3]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BatteryPowerAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BatteryPowerAdc {
                #[inline]
                fn eq(&self, other: &BatteryPowerAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for BatteryPowerAdc {
                const SIZE_BITS: u32 = 24;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl BatteryPowerAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 3] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u32 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u32,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 24)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u32) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u32,
                            ::device_driver::ops::BE,
                        >(raw, 0, 24, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 3]> for BatteryPowerAdc {
                fn from(bits: [u8; 3]) -> Self {
                    Self { bits }
                }
            }
            impl From<BatteryPowerAdc> for [u8; 3] {
                fn from(val: BatteryPowerAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for BatteryPowerAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("BatteryPowerAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for BatteryPowerAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for BatteryPowerAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for BatteryPowerAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for BatteryPowerAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for BatteryPowerAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for BatteryPowerAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for BatteryPowerAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct BatteryVoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for BatteryVoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for BatteryVoltageAdc {
                #[inline]
                fn clone(&self) -> BatteryVoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for BatteryVoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for BatteryVoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for BatteryVoltageAdc {
                #[inline]
                fn eq(&self, other: &BatteryVoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for BatteryVoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl BatteryVoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for BatteryVoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<BatteryVoltageAdc> for [u8; 2] {
                fn from(val: BatteryVoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for BatteryVoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("BatteryVoltageAdc")
                        .field("raw", &self.raw())
                        .finish()
                }
            }
            impl core::ops::BitAnd for BatteryVoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for BatteryVoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for BatteryVoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for BatteryVoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for BatteryVoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for BatteryVoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for BatteryVoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct ChargeCurrentAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ChargeCurrentAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for ChargeCurrentAdc {
                #[inline]
                fn clone(&self) -> ChargeCurrentAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ChargeCurrentAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ChargeCurrentAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ChargeCurrentAdc {
                #[inline]
                fn eq(&self, other: &ChargeCurrentAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ChargeCurrentAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ChargeCurrentAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for ChargeCurrentAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<ChargeCurrentAdc> for [u8; 2] {
                fn from(val: ChargeCurrentAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ChargeCurrentAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ChargeCurrentAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for ChargeCurrentAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ChargeCurrentAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ChargeCurrentAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ChargeCurrentAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ChargeCurrentAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ChargeCurrentAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ChargeCurrentAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct DischargeCurrentAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DischargeCurrentAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for DischargeCurrentAdc {
                #[inline]
                fn clone(&self) -> DischargeCurrentAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DischargeCurrentAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DischargeCurrentAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DischargeCurrentAdc {
                #[inline]
                fn eq(&self, other: &DischargeCurrentAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DischargeCurrentAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DischargeCurrentAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for DischargeCurrentAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<DischargeCurrentAdc> for [u8; 2] {
                fn from(val: DischargeCurrentAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DischargeCurrentAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DischargeCurrentAdc")
                        .field("raw", &self.raw())
                        .finish()
                }
            }
            impl core::ops::BitAnd for DischargeCurrentAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DischargeCurrentAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DischargeCurrentAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DischargeCurrentAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DischargeCurrentAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DischargeCurrentAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DischargeCurrentAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///
            pub struct ApsVoltageAdc {
                /// The internal bits
                bits: [u8; 2],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ApsVoltageAdc {}
            #[automatically_derived]
            impl ::core::clone::Clone for ApsVoltageAdc {
                #[inline]
                fn clone(&self) -> ApsVoltageAdc {
                    let _: ::core::clone::AssertParamIsClone<[u8; 2]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ApsVoltageAdc {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 2]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ApsVoltageAdc {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ApsVoltageAdc {
                #[inline]
                fn eq(&self, other: &ApsVoltageAdc) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ApsVoltageAdc {
                const SIZE_BITS: u32 = 16;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ApsVoltageAdc {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 2] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u16 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 16)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u16) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u16,
                            ::device_driver::ops::BE,
                        >(raw, 0, 16, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 2]> for ApsVoltageAdc {
                fn from(bits: [u8; 2]) -> Self {
                    Self { bits }
                }
            }
            impl From<ApsVoltageAdc> for [u8; 2] {
                fn from(val: ApsVoltageAdc) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ApsVoltageAdc {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ApsVoltageAdc").field("raw", &self.raw()).finish()
                }
            }
            impl core::ops::BitAnd for ApsVoltageAdc {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ApsVoltageAdc {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ApsVoltageAdc {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ApsVoltageAdc {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ApsVoltageAdc {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ApsVoltageAdc {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ApsVoltageAdc {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Charge coulomb counter value.
            pub struct ChargeCoulombCounter {
                /// The internal bits
                bits: [u8; 4],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for ChargeCoulombCounter {}
            #[automatically_derived]
            impl ::core::clone::Clone for ChargeCoulombCounter {
                #[inline]
                fn clone(&self) -> ChargeCoulombCounter {
                    let _: ::core::clone::AssertParamIsClone<[u8; 4]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for ChargeCoulombCounter {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 4]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for ChargeCoulombCounter {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for ChargeCoulombCounter {
                #[inline]
                fn eq(&self, other: &ChargeCoulombCounter) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for ChargeCoulombCounter {
                const SIZE_BITS: u32 = 32;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl ChargeCoulombCounter {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8, 0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 4] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u32 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u32,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 32)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u32) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u32,
                            ::device_driver::ops::BE,
                        >(raw, 0, 32, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 4]> for ChargeCoulombCounter {
                fn from(bits: [u8; 4]) -> Self {
                    Self { bits }
                }
            }
            impl From<ChargeCoulombCounter> for [u8; 4] {
                fn from(val: ChargeCoulombCounter) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for ChargeCoulombCounter {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("ChargeCoulombCounter")
                        .field("raw", &self.raw())
                        .finish()
                }
            }
            impl core::ops::BitAnd for ChargeCoulombCounter {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for ChargeCoulombCounter {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for ChargeCoulombCounter {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for ChargeCoulombCounter {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for ChargeCoulombCounter {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for ChargeCoulombCounter {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for ChargeCoulombCounter {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Discharge coulomb counter value.
            pub struct DischargeCoulombCounter {
                /// The internal bits
                bits: [u8; 4],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for DischargeCoulombCounter {}
            #[automatically_derived]
            impl ::core::clone::Clone for DischargeCoulombCounter {
                #[inline]
                fn clone(&self) -> DischargeCoulombCounter {
                    let _: ::core::clone::AssertParamIsClone<[u8; 4]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for DischargeCoulombCounter {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 4]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for DischargeCoulombCounter {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for DischargeCoulombCounter {
                #[inline]
                fn eq(&self, other: &DischargeCoulombCounter) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for DischargeCoulombCounter {
                const SIZE_BITS: u32 = 32;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl DischargeCoulombCounter {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8, 0u8, 0u8, 0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 4] }
                }
                ///Read the `raw` field of the register.
                ///
                ///
                pub fn raw(&self) -> u32 {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u32,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 32)
                    };
                    raw
                }
                ///Write the `raw` field of the register.
                ///
                ///
                pub fn set_raw(&mut self, value: u32) {
                    let raw = value;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u32,
                            ::device_driver::ops::BE,
                        >(raw, 0, 32, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 4]> for DischargeCoulombCounter {
                fn from(bits: [u8; 4]) -> Self {
                    Self { bits }
                }
            }
            impl From<DischargeCoulombCounter> for [u8; 4] {
                fn from(val: DischargeCoulombCounter) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for DischargeCoulombCounter {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("DischargeCoulombCounter")
                        .field("raw", &self.raw())
                        .finish()
                }
            }
            impl core::ops::BitAnd for DischargeCoulombCounter {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for DischargeCoulombCounter {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for DischargeCoulombCounter {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for DischargeCoulombCounter {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for DischargeCoulombCounter {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for DischargeCoulombCounter {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for DischargeCoulombCounter {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            ///Coulomb counter control.
            pub struct CoulombCounterControl {
                /// The internal bits
                bits: [u8; 1],
            }
            #[automatically_derived]
            impl ::core::marker::Copy for CoulombCounterControl {}
            #[automatically_derived]
            impl ::core::clone::Clone for CoulombCounterControl {
                #[inline]
                fn clone(&self) -> CoulombCounterControl {
                    let _: ::core::clone::AssertParamIsClone<[u8; 1]>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Eq for CoulombCounterControl {
                #[inline]
                #[doc(hidden)]
                #[coverage(off)]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<[u8; 1]>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for CoulombCounterControl {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for CoulombCounterControl {
                #[inline]
                fn eq(&self, other: &CoulombCounterControl) -> bool {
                    self.bits == other.bits
                }
            }
            impl ::device_driver::FieldSet for CoulombCounterControl {
                const SIZE_BITS: u32 = 8;
                fn new_with_zero() -> Self {
                    Self::new_zero()
                }
                fn get_inner_buffer(&self) -> &[u8] {
                    &self.bits
                }
                fn get_inner_buffer_mut(&mut self) -> &mut [u8] {
                    &mut self.bits
                }
            }
            impl CoulombCounterControl {
                /// Create a new instance, loaded with the reset value (if any)
                pub const fn new() -> Self {
                    Self { bits: [0u8] }
                }
                /// Create a new instance, loaded with all zeroes
                pub const fn new_zero() -> Self {
                    Self { bits: [0; 1] }
                }
                ///Read the `enable` field of the register.
                ///
                ///Enable coulomb counter (1: enable)
                pub fn enable(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 0, 1)
                    };
                    raw > 0
                }
                ///Read the `suspend` field of the register.
                ///
                ///Suspend coulomb counter (1: suspend)
                pub fn suspend(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 1, 2)
                    };
                    raw > 0
                }
                ///Read the `clear` field of the register.
                ///
                ///Clear coulomb counter (1: clear, self-clearing)
                pub fn clear(&self) -> bool {
                    let raw = unsafe {
                        ::device_driver::ops::load_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(&self.bits, 2, 3)
                    };
                    raw > 0
                }
                ///Write the `enable` field of the register.
                ///
                ///Enable coulomb counter (1: enable)
                pub fn set_enable(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 0, 1, &mut self.bits)
                    };
                }
                ///Write the `suspend` field of the register.
                ///
                ///Suspend coulomb counter (1: suspend)
                pub fn set_suspend(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 1, 2, &mut self.bits)
                    };
                }
                ///Write the `clear` field of the register.
                ///
                ///Clear coulomb counter (1: clear, self-clearing)
                pub fn set_clear(&mut self, value: bool) {
                    let raw = value as _;
                    unsafe {
                        ::device_driver::ops::store_lsb0::<
                            u8,
                            ::device_driver::ops::BE,
                        >(raw, 2, 3, &mut self.bits)
                    };
                }
            }
            impl From<[u8; 1]> for CoulombCounterControl {
                fn from(bits: [u8; 1]) -> Self {
                    Self { bits }
                }
            }
            impl From<CoulombCounterControl> for [u8; 1] {
                fn from(val: CoulombCounterControl) -> Self {
                    val.bits
                }
            }
            impl core::fmt::Debug for CoulombCounterControl {
                fn fmt(
                    &self,
                    f: &mut core::fmt::Formatter<'_>,
                ) -> Result<(), core::fmt::Error> {
                    f.debug_struct("CoulombCounterControl")
                        .field("enable", &self.enable())
                        .field("suspend", &self.suspend())
                        .field("clear", &self.clear())
                        .finish()
                }
            }
            impl core::ops::BitAnd for CoulombCounterControl {
                type Output = Self;
                fn bitand(mut self, rhs: Self) -> Self::Output {
                    self &= rhs;
                    self
                }
            }
            impl core::ops::BitAndAssign for CoulombCounterControl {
                fn bitand_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l &= *r;
                    }
                }
            }
            impl core::ops::BitOr for CoulombCounterControl {
                type Output = Self;
                fn bitor(mut self, rhs: Self) -> Self::Output {
                    self |= rhs;
                    self
                }
            }
            impl core::ops::BitOrAssign for CoulombCounterControl {
                fn bitor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l |= *r;
                    }
                }
            }
            impl core::ops::BitXor for CoulombCounterControl {
                type Output = Self;
                fn bitxor(mut self, rhs: Self) -> Self::Output {
                    self ^= rhs;
                    self
                }
            }
            impl core::ops::BitXorAssign for CoulombCounterControl {
                fn bitxor_assign(&mut self, rhs: Self) {
                    for (l, r) in self.bits.iter_mut().zip(&rhs.bits) {
                        *l ^= *r;
                    }
                }
            }
            impl core::ops::Not for CoulombCounterControl {
                type Output = Self;
                fn not(mut self) -> Self::Output {
                    for val in self.bits.iter_mut() {
                        *val = !*val;
                    }
                    self
                }
            }
            /// Enum containing all possible field set types
            pub enum FieldSetValue {
                ///Input power status.
                PowerStatus(PowerStatus),
                ///Charging and battery status.
                ChargeStatus(ChargeStatus),
                ///OTG VBUS status.
                OtgVbusStatus(OtgVbusStatus),
                ///Data Buffer 0
                DataBuffer0(DataBuffer0),
                ///Data Buffer 1
                DataBuffer1(DataBuffer1),
                ///Data Buffer 2
                DataBuffer2(DataBuffer2),
                ///Data Buffer 3
                DataBuffer3(DataBuffer3),
                ///Data Buffer 4
                DataBuffer4(DataBuffer4),
                ///Data Buffer 5
                DataBuffer5(DataBuffer5),
                ///EXTEN and DC-DC2 enable control.
                ExtenDcdc2Control(ExtenDcdc2Control),
                ///Power output control for DCDC1/3, LDO2/3. Note: DCDC2/EXTEN control also here.
                Dcdc13Ldo23Control(Dcdc13Ldo23Control),
                ///DC-DC2 output voltage setting (0.7-2.275V or 0.7-3.5V, 25mV/step - check datasheet for your variant).
                Dcdc2Voltage(Dcdc2Voltage),
                ///DC-DC2 VRC slope control.
                Dcdc2Slope(Dcdc2Slope),
                ///DC-DC1 output voltage setting (0.7-3.5V, 25mV/step).
                Dcdc1Voltage(Dcdc1Voltage),
                ///DC-DC3 output voltage setting (0.7-3.5V, 25mV/step).
                Dcdc3Voltage(Dcdc3Voltage),
                ///LDO2/LDO3 output voltage settings (1.8-3.3V, 100mV/step).
                Ldo23Voltage(Ldo23Voltage),
                ///VBUS-IPSOUT path control and VBUS current limit.
                VbusIpsoutChannel(VbusIpsoutChannel),
                ///Voff shutdown voltage and Pek function control.
                ShutdownVoltage(ShutdownVoltage),
                ///Shutdown behavior, CHGLED control.
                ShutdownBatteryChgledControl(ShutdownBatteryChgledControl),
                ///Charging control 1: target voltage, current, end current.
                ChargeControl1(ChargeControl1),
                ///Charging control 2: pre-charge time, constant current timeout.
                ChargeControl2(ChargeControl2),
                ///Backup battery charging control and other battery features.
                BatteryChargeControl(BatteryChargeControl),
                ///PEK button settings: boot/shutdown times, power on/off behavior.
                PekSettings(PekSettings),
                ///DCDC working frequency setting.
                DcdcFrequency(DcdcFrequency),
                ///Battery charge low temperature threshold.
                BatteryChargeLowTemp(BatteryChargeLowTemp),
                ///Battery charge high temperature threshold.
                BatteryChargeHighTemp(BatteryChargeHighTemp),
                ///APS low power level 1 setting.
                ApsLowPower1(ApsLowPower1),
                ///APS low power level 2 setting.
                ApsLowPower2(ApsLowPower2),
                ///Battery discharge low temperature threshold.
                BatteryDischargeLowTemp(BatteryDischargeLowTemp),
                ///Battery discharge high temperature threshold.
                BatteryDischargeHighTemp(BatteryDischargeHighTemp),
                ///DCDC working mode control (Auto/PWM).
                DcdcMode(DcdcMode),
                ///ADC enable control 1.
                AdcEnable1(AdcEnable1),
                ///ADC enable control 2 (GPIO ADCs, internal temp).
                AdcEnable2(AdcEnable2),
                ///ADC sample rate, TS pin control.
                AdcRateTsPin(AdcRateTsPin),
                ///GPIO0-3 ADC input range.
                Gpio30InputRange(Gpio30InputRange),
                ///GPIO0 ADC IRQ rising edge threshold.
                Gpio0AdcIrqRising(Gpio0AdcIrqRising),
                ///GPIO0 ADC IRQ falling edge threshold.
                Gpio0AdcIrqFalling(Gpio0AdcIrqFalling),
                ///Timer control.
                TimerControl(TimerControl),
                ///VBUS monitor, salkl aralk ayar.
                VbusMonitor(VbusMonitor),
                ///Over temperature shutdown control.
                TempShutdownControl(TempShutdownControl),
                ///
                Gpio0Control(Gpio0Control),
                ///GPIO0 LDO (LDOIO0) output voltage setting.
                Gpio0Ldoio0Voltage(Gpio0Ldoio0Voltage),
                ///
                Gpio1Control(Gpio1Control),
                ///
                Gpio2Control(Gpio2Control),
                ///
                Gpio20SignalStatus(Gpio20SignalStatus),
                ///GPIO3/4 function control.
                Gpio43FunctionControl(Gpio43FunctionControl),
                ///GPIO3/4 output level control and input status.
                Gpio43SignalStatus(Gpio43SignalStatus),
                ///GPIO0-2 pulldown resistor control.
                Gpio20PulldownControl(Gpio20PulldownControl),
                ///PWM1 frequency setting.
                Pwm1Frequency(Pwm1Frequency),
                ///PWM1 duty cycle MSBs.
                Pwm1DutyCycle1(Pwm1DutyCycle1),
                ///PWM1 duty cycle LSBs.
                Pwm1DutyCycle2(Pwm1DutyCycle2),
                ///PWM2 frequency setting.
                Pwm2Frequency(Pwm2Frequency),
                ///PWM2 duty cycle MSBs.
                Pwm2DutyCycle1(Pwm2DutyCycle1),
                ///PWM2 duty cycle LSBs.
                Pwm2DutyCycle2(Pwm2DutyCycle2),
                ///N_RSTO (Reset Out) / GPIO5 control.
                NRstoGpio5Control(NRstoGpio5Control),
                ///Interrupt Enable Control 1.
                EnableControl1(EnableControl1),
                ///Interrupt Enable Control 2.
                EnableControl2(EnableControl2),
                ///Interrupt Enable Control 3.
                EnableControl3(EnableControl3),
                ///Interrupt Enable Control 4.
                EnableControl4(EnableControl4),
                ///Interrupt Enable Control 5.
                EnableControl5(EnableControl5),
                ///Interrupt Status 1 (Write 1 to clear).
                IrqStatus1(IrqStatus1),
                ///Interrupt Status 2.
                IrqStatus2(IrqStatus2),
                ///Interrupt Status 3.
                IrqStatus3(IrqStatus3),
                ///Interrupt Status 4.
                IrqStatus4(IrqStatus4),
                ///Interrupt Status 5.
                IrqStatus5(IrqStatus5),
                ///
                AcinVoltageAdc(AcinVoltageAdc),
                ///
                AcinCurrentAdc(AcinCurrentAdc),
                ///
                VbusVoltageAdc(VbusVoltageAdc),
                ///
                VbusCurrentAdc(VbusCurrentAdc),
                ///
                InternalTemperatureAdc(InternalTemperatureAdc),
                ///
                TsInputAdc(TsInputAdc),
                ///
                Gpio0VoltageAdc(Gpio0VoltageAdc),
                ///
                Gpio1VoltageAdc(Gpio1VoltageAdc),
                ///
                Gpio2VoltageAdc(Gpio2VoltageAdc),
                ///
                Gpio3VoltageAdc(Gpio3VoltageAdc),
                ///Battery power ADC raw value (23-bit result).
                BatteryPowerAdc(BatteryPowerAdc),
                ///
                BatteryVoltageAdc(BatteryVoltageAdc),
                ///
                ChargeCurrentAdc(ChargeCurrentAdc),
                ///
                DischargeCurrentAdc(DischargeCurrentAdc),
                ///
                ApsVoltageAdc(ApsVoltageAdc),
                ///Charge coulomb counter value.
                ChargeCoulombCounter(ChargeCoulombCounter),
                ///Discharge coulomb counter value.
                DischargeCoulombCounter(DischargeCoulombCounter),
                ///Coulomb counter control.
                CoulombCounterControl(CoulombCounterControl),
            }
            impl core::fmt::Debug for FieldSetValue {
                fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                    match self {
                        Self::PowerStatus(val) => core::fmt::Debug::fmt(val, f),
                        Self::ChargeStatus(val) => core::fmt::Debug::fmt(val, f),
                        Self::OtgVbusStatus(val) => core::fmt::Debug::fmt(val, f),
                        Self::DataBuffer0(val) => core::fmt::Debug::fmt(val, f),
                        Self::DataBuffer1(val) => core::fmt::Debug::fmt(val, f),
                        Self::DataBuffer2(val) => core::fmt::Debug::fmt(val, f),
                        Self::DataBuffer3(val) => core::fmt::Debug::fmt(val, f),
                        Self::DataBuffer4(val) => core::fmt::Debug::fmt(val, f),
                        Self::DataBuffer5(val) => core::fmt::Debug::fmt(val, f),
                        Self::ExtenDcdc2Control(val) => core::fmt::Debug::fmt(val, f),
                        Self::Dcdc13Ldo23Control(val) => core::fmt::Debug::fmt(val, f),
                        Self::Dcdc2Voltage(val) => core::fmt::Debug::fmt(val, f),
                        Self::Dcdc2Slope(val) => core::fmt::Debug::fmt(val, f),
                        Self::Dcdc1Voltage(val) => core::fmt::Debug::fmt(val, f),
                        Self::Dcdc3Voltage(val) => core::fmt::Debug::fmt(val, f),
                        Self::Ldo23Voltage(val) => core::fmt::Debug::fmt(val, f),
                        Self::VbusIpsoutChannel(val) => core::fmt::Debug::fmt(val, f),
                        Self::ShutdownVoltage(val) => core::fmt::Debug::fmt(val, f),
                        Self::ShutdownBatteryChgledControl(val) => {
                            core::fmt::Debug::fmt(val, f)
                        }
                        Self::ChargeControl1(val) => core::fmt::Debug::fmt(val, f),
                        Self::ChargeControl2(val) => core::fmt::Debug::fmt(val, f),
                        Self::BatteryChargeControl(val) => core::fmt::Debug::fmt(val, f),
                        Self::PekSettings(val) => core::fmt::Debug::fmt(val, f),
                        Self::DcdcFrequency(val) => core::fmt::Debug::fmt(val, f),
                        Self::BatteryChargeLowTemp(val) => core::fmt::Debug::fmt(val, f),
                        Self::BatteryChargeHighTemp(val) => core::fmt::Debug::fmt(val, f),
                        Self::ApsLowPower1(val) => core::fmt::Debug::fmt(val, f),
                        Self::ApsLowPower2(val) => core::fmt::Debug::fmt(val, f),
                        Self::BatteryDischargeLowTemp(val) => {
                            core::fmt::Debug::fmt(val, f)
                        }
                        Self::BatteryDischargeHighTemp(val) => {
                            core::fmt::Debug::fmt(val, f)
                        }
                        Self::DcdcMode(val) => core::fmt::Debug::fmt(val, f),
                        Self::AdcEnable1(val) => core::fmt::Debug::fmt(val, f),
                        Self::AdcEnable2(val) => core::fmt::Debug::fmt(val, f),
                        Self::AdcRateTsPin(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio30InputRange(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio0AdcIrqRising(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio0AdcIrqFalling(val) => core::fmt::Debug::fmt(val, f),
                        Self::TimerControl(val) => core::fmt::Debug::fmt(val, f),
                        Self::VbusMonitor(val) => core::fmt::Debug::fmt(val, f),
                        Self::TempShutdownControl(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio0Control(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio0Ldoio0Voltage(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio1Control(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio2Control(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio20SignalStatus(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio43FunctionControl(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio43SignalStatus(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio20PulldownControl(val) => core::fmt::Debug::fmt(val, f),
                        Self::Pwm1Frequency(val) => core::fmt::Debug::fmt(val, f),
                        Self::Pwm1DutyCycle1(val) => core::fmt::Debug::fmt(val, f),
                        Self::Pwm1DutyCycle2(val) => core::fmt::Debug::fmt(val, f),
                        Self::Pwm2Frequency(val) => core::fmt::Debug::fmt(val, f),
                        Self::Pwm2DutyCycle1(val) => core::fmt::Debug::fmt(val, f),
                        Self::Pwm2DutyCycle2(val) => core::fmt::Debug::fmt(val, f),
                        Self::NRstoGpio5Control(val) => core::fmt::Debug::fmt(val, f),
                        Self::EnableControl1(val) => core::fmt::Debug::fmt(val, f),
                        Self::EnableControl2(val) => core::fmt::Debug::fmt(val, f),
                        Self::EnableControl3(val) => core::fmt::Debug::fmt(val, f),
                        Self::EnableControl4(val) => core::fmt::Debug::fmt(val, f),
                        Self::EnableControl5(val) => core::fmt::Debug::fmt(val, f),
                        Self::IrqStatus1(val) => core::fmt::Debug::fmt(val, f),
                        Self::IrqStatus2(val) => core::fmt::Debug::fmt(val, f),
                        Self::IrqStatus3(val) => core::fmt::Debug::fmt(val, f),
                        Self::IrqStatus4(val) => core::fmt::Debug::fmt(val, f),
                        Self::IrqStatus5(val) => core::fmt::Debug::fmt(val, f),
                        Self::AcinVoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::AcinCurrentAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::VbusVoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::VbusCurrentAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::InternalTemperatureAdc(val) => {
                            core::fmt::Debug::fmt(val, f)
                        }
                        Self::TsInputAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio0VoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio1VoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio2VoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::Gpio3VoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::BatteryPowerAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::BatteryVoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::ChargeCurrentAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::DischargeCurrentAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::ApsVoltageAdc(val) => core::fmt::Debug::fmt(val, f),
                        Self::ChargeCoulombCounter(val) => core::fmt::Debug::fmt(val, f),
                        Self::DischargeCoulombCounter(val) => {
                            core::fmt::Debug::fmt(val, f)
                        }
                        Self::CoulombCounterControl(val) => core::fmt::Debug::fmt(val, f),
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            );
                        }
                    }
                }
            }
            impl From<PowerStatus> for FieldSetValue {
                fn from(val: PowerStatus) -> Self {
                    Self::PowerStatus(val)
                }
            }
            impl From<ChargeStatus> for FieldSetValue {
                fn from(val: ChargeStatus) -> Self {
                    Self::ChargeStatus(val)
                }
            }
            impl From<OtgVbusStatus> for FieldSetValue {
                fn from(val: OtgVbusStatus) -> Self {
                    Self::OtgVbusStatus(val)
                }
            }
            impl From<DataBuffer0> for FieldSetValue {
                fn from(val: DataBuffer0) -> Self {
                    Self::DataBuffer0(val)
                }
            }
            impl From<DataBuffer1> for FieldSetValue {
                fn from(val: DataBuffer1) -> Self {
                    Self::DataBuffer1(val)
                }
            }
            impl From<DataBuffer2> for FieldSetValue {
                fn from(val: DataBuffer2) -> Self {
                    Self::DataBuffer2(val)
                }
            }
            impl From<DataBuffer3> for FieldSetValue {
                fn from(val: DataBuffer3) -> Self {
                    Self::DataBuffer3(val)
                }
            }
            impl From<DataBuffer4> for FieldSetValue {
                fn from(val: DataBuffer4) -> Self {
                    Self::DataBuffer4(val)
                }
            }
            impl From<DataBuffer5> for FieldSetValue {
                fn from(val: DataBuffer5) -> Self {
                    Self::DataBuffer5(val)
                }
            }
            impl From<ExtenDcdc2Control> for FieldSetValue {
                fn from(val: ExtenDcdc2Control) -> Self {
                    Self::ExtenDcdc2Control(val)
                }
            }
            impl From<Dcdc13Ldo23Control> for FieldSetValue {
                fn from(val: Dcdc13Ldo23Control) -> Self {
                    Self::Dcdc13Ldo23Control(val)
                }
            }
            impl From<Dcdc2Voltage> for FieldSetValue {
                fn from(val: Dcdc2Voltage) -> Self {
                    Self::Dcdc2Voltage(val)
                }
            }
            impl From<Dcdc2Slope> for FieldSetValue {
                fn from(val: Dcdc2Slope) -> Self {
                    Self::Dcdc2Slope(val)
                }
            }
            impl From<Dcdc1Voltage> for FieldSetValue {
                fn from(val: Dcdc1Voltage) -> Self {
                    Self::Dcdc1Voltage(val)
                }
            }
            impl From<Dcdc3Voltage> for FieldSetValue {
                fn from(val: Dcdc3Voltage) -> Self {
                    Self::Dcdc3Voltage(val)
                }
            }
            impl From<Ldo23Voltage> for FieldSetValue {
                fn from(val: Ldo23Voltage) -> Self {
                    Self::Ldo23Voltage(val)
                }
            }
            impl From<VbusIpsoutChannel> for FieldSetValue {
                fn from(val: VbusIpsoutChannel) -> Self {
                    Self::VbusIpsoutChannel(val)
                }
            }
            impl From<ShutdownVoltage> for FieldSetValue {
                fn from(val: ShutdownVoltage) -> Self {
                    Self::ShutdownVoltage(val)
                }
            }
            impl From<ShutdownBatteryChgledControl> for FieldSetValue {
                fn from(val: ShutdownBatteryChgledControl) -> Self {
                    Self::ShutdownBatteryChgledControl(val)
                }
            }
            impl From<ChargeControl1> for FieldSetValue {
                fn from(val: ChargeControl1) -> Self {
                    Self::ChargeControl1(val)
                }
            }
            impl From<ChargeControl2> for FieldSetValue {
                fn from(val: ChargeControl2) -> Self {
                    Self::ChargeControl2(val)
                }
            }
            impl From<BatteryChargeControl> for FieldSetValue {
                fn from(val: BatteryChargeControl) -> Self {
                    Self::BatteryChargeControl(val)
                }
            }
            impl From<PekSettings> for FieldSetValue {
                fn from(val: PekSettings) -> Self {
                    Self::PekSettings(val)
                }
            }
            impl From<DcdcFrequency> for FieldSetValue {
                fn from(val: DcdcFrequency) -> Self {
                    Self::DcdcFrequency(val)
                }
            }
            impl From<BatteryChargeLowTemp> for FieldSetValue {
                fn from(val: BatteryChargeLowTemp) -> Self {
                    Self::BatteryChargeLowTemp(val)
                }
            }
            impl From<BatteryChargeHighTemp> for FieldSetValue {
                fn from(val: BatteryChargeHighTemp) -> Self {
                    Self::BatteryChargeHighTemp(val)
                }
            }
            impl From<ApsLowPower1> for FieldSetValue {
                fn from(val: ApsLowPower1) -> Self {
                    Self::ApsLowPower1(val)
                }
            }
            impl From<ApsLowPower2> for FieldSetValue {
                fn from(val: ApsLowPower2) -> Self {
                    Self::ApsLowPower2(val)
                }
            }
            impl From<BatteryDischargeLowTemp> for FieldSetValue {
                fn from(val: BatteryDischargeLowTemp) -> Self {
                    Self::BatteryDischargeLowTemp(val)
                }
            }
            impl From<BatteryDischargeHighTemp> for FieldSetValue {
                fn from(val: BatteryDischargeHighTemp) -> Self {
                    Self::BatteryDischargeHighTemp(val)
                }
            }
            impl From<DcdcMode> for FieldSetValue {
                fn from(val: DcdcMode) -> Self {
                    Self::DcdcMode(val)
                }
            }
            impl From<AdcEnable1> for FieldSetValue {
                fn from(val: AdcEnable1) -> Self {
                    Self::AdcEnable1(val)
                }
            }
            impl From<AdcEnable2> for FieldSetValue {
                fn from(val: AdcEnable2) -> Self {
                    Self::AdcEnable2(val)
                }
            }
            impl From<AdcRateTsPin> for FieldSetValue {
                fn from(val: AdcRateTsPin) -> Self {
                    Self::AdcRateTsPin(val)
                }
            }
            impl From<Gpio30InputRange> for FieldSetValue {
                fn from(val: Gpio30InputRange) -> Self {
                    Self::Gpio30InputRange(val)
                }
            }
            impl From<Gpio0AdcIrqRising> for FieldSetValue {
                fn from(val: Gpio0AdcIrqRising) -> Self {
                    Self::Gpio0AdcIrqRising(val)
                }
            }
            impl From<Gpio0AdcIrqFalling> for FieldSetValue {
                fn from(val: Gpio0AdcIrqFalling) -> Self {
                    Self::Gpio0AdcIrqFalling(val)
                }
            }
            impl From<TimerControl> for FieldSetValue {
                fn from(val: TimerControl) -> Self {
                    Self::TimerControl(val)
                }
            }
            impl From<VbusMonitor> for FieldSetValue {
                fn from(val: VbusMonitor) -> Self {
                    Self::VbusMonitor(val)
                }
            }
            impl From<TempShutdownControl> for FieldSetValue {
                fn from(val: TempShutdownControl) -> Self {
                    Self::TempShutdownControl(val)
                }
            }
            impl From<Gpio0Control> for FieldSetValue {
                fn from(val: Gpio0Control) -> Self {
                    Self::Gpio0Control(val)
                }
            }
            impl From<Gpio0Ldoio0Voltage> for FieldSetValue {
                fn from(val: Gpio0Ldoio0Voltage) -> Self {
                    Self::Gpio0Ldoio0Voltage(val)
                }
            }
            impl From<Gpio1Control> for FieldSetValue {
                fn from(val: Gpio1Control) -> Self {
                    Self::Gpio1Control(val)
                }
            }
            impl From<Gpio2Control> for FieldSetValue {
                fn from(val: Gpio2Control) -> Self {
                    Self::Gpio2Control(val)
                }
            }
            impl From<Gpio20SignalStatus> for FieldSetValue {
                fn from(val: Gpio20SignalStatus) -> Self {
                    Self::Gpio20SignalStatus(val)
                }
            }
            impl From<Gpio43FunctionControl> for FieldSetValue {
                fn from(val: Gpio43FunctionControl) -> Self {
                    Self::Gpio43FunctionControl(val)
                }
            }
            impl From<Gpio43SignalStatus> for FieldSetValue {
                fn from(val: Gpio43SignalStatus) -> Self {
                    Self::Gpio43SignalStatus(val)
                }
            }
            impl From<Gpio20PulldownControl> for FieldSetValue {
                fn from(val: Gpio20PulldownControl) -> Self {
                    Self::Gpio20PulldownControl(val)
                }
            }
            impl From<Pwm1Frequency> for FieldSetValue {
                fn from(val: Pwm1Frequency) -> Self {
                    Self::Pwm1Frequency(val)
                }
            }
            impl From<Pwm1DutyCycle1> for FieldSetValue {
                fn from(val: Pwm1DutyCycle1) -> Self {
                    Self::Pwm1DutyCycle1(val)
                }
            }
            impl From<Pwm1DutyCycle2> for FieldSetValue {
                fn from(val: Pwm1DutyCycle2) -> Self {
                    Self::Pwm1DutyCycle2(val)
                }
            }
            impl From<Pwm2Frequency> for FieldSetValue {
                fn from(val: Pwm2Frequency) -> Self {
                    Self::Pwm2Frequency(val)
                }
            }
            impl From<Pwm2DutyCycle1> for FieldSetValue {
                fn from(val: Pwm2DutyCycle1) -> Self {
                    Self::Pwm2DutyCycle1(val)
                }
            }
            impl From<Pwm2DutyCycle2> for FieldSetValue {
                fn from(val: Pwm2DutyCycle2) -> Self {
                    Self::Pwm2DutyCycle2(val)
                }
            }
            impl From<NRstoGpio5Control> for FieldSetValue {
                fn from(val: NRstoGpio5Control) -> Self {
                    Self::NRstoGpio5Control(val)
                }
            }
            impl From<EnableControl1> for FieldSetValue {
                fn from(val: EnableControl1) -> Self {
                    Self::EnableControl1(val)
                }
            }
            impl From<EnableControl2> for FieldSetValue {
                fn from(val: EnableControl2) -> Self {
                    Self::EnableControl2(val)
                }
            }
            impl From<EnableControl3> for FieldSetValue {
                fn from(val: EnableControl3) -> Self {
                    Self::EnableControl3(val)
                }
            }
            impl From<EnableControl4> for FieldSetValue {
                fn from(val: EnableControl4) -> Self {
                    Self::EnableControl4(val)
                }
            }
            impl From<EnableControl5> for FieldSetValue {
                fn from(val: EnableControl5) -> Self {
                    Self::EnableControl5(val)
                }
            }
            impl From<IrqStatus1> for FieldSetValue {
                fn from(val: IrqStatus1) -> Self {
                    Self::IrqStatus1(val)
                }
            }
            impl From<IrqStatus2> for FieldSetValue {
                fn from(val: IrqStatus2) -> Self {
                    Self::IrqStatus2(val)
                }
            }
            impl From<IrqStatus3> for FieldSetValue {
                fn from(val: IrqStatus3) -> Self {
                    Self::IrqStatus3(val)
                }
            }
            impl From<IrqStatus4> for FieldSetValue {
                fn from(val: IrqStatus4) -> Self {
                    Self::IrqStatus4(val)
                }
            }
            impl From<IrqStatus5> for FieldSetValue {
                fn from(val: IrqStatus5) -> Self {
                    Self::IrqStatus5(val)
                }
            }
            impl From<AcinVoltageAdc> for FieldSetValue {
                fn from(val: AcinVoltageAdc) -> Self {
                    Self::AcinVoltageAdc(val)
                }
            }
            impl From<AcinCurrentAdc> for FieldSetValue {
                fn from(val: AcinCurrentAdc) -> Self {
                    Self::AcinCurrentAdc(val)
                }
            }
            impl From<VbusVoltageAdc> for FieldSetValue {
                fn from(val: VbusVoltageAdc) -> Self {
                    Self::VbusVoltageAdc(val)
                }
            }
            impl From<VbusCurrentAdc> for FieldSetValue {
                fn from(val: VbusCurrentAdc) -> Self {
                    Self::VbusCurrentAdc(val)
                }
            }
            impl From<InternalTemperatureAdc> for FieldSetValue {
                fn from(val: InternalTemperatureAdc) -> Self {
                    Self::InternalTemperatureAdc(val)
                }
            }
            impl From<TsInputAdc> for FieldSetValue {
                fn from(val: TsInputAdc) -> Self {
                    Self::TsInputAdc(val)
                }
            }
            impl From<Gpio0VoltageAdc> for FieldSetValue {
                fn from(val: Gpio0VoltageAdc) -> Self {
                    Self::Gpio0VoltageAdc(val)
                }
            }
            impl From<Gpio1VoltageAdc> for FieldSetValue {
                fn from(val: Gpio1VoltageAdc) -> Self {
                    Self::Gpio1VoltageAdc(val)
                }
            }
            impl From<Gpio2VoltageAdc> for FieldSetValue {
                fn from(val: Gpio2VoltageAdc) -> Self {
                    Self::Gpio2VoltageAdc(val)
                }
            }
            impl From<Gpio3VoltageAdc> for FieldSetValue {
                fn from(val: Gpio3VoltageAdc) -> Self {
                    Self::Gpio3VoltageAdc(val)
                }
            }
            impl From<BatteryPowerAdc> for FieldSetValue {
                fn from(val: BatteryPowerAdc) -> Self {
                    Self::BatteryPowerAdc(val)
                }
            }
            impl From<BatteryVoltageAdc> for FieldSetValue {
                fn from(val: BatteryVoltageAdc) -> Self {
                    Self::BatteryVoltageAdc(val)
                }
            }
            impl From<ChargeCurrentAdc> for FieldSetValue {
                fn from(val: ChargeCurrentAdc) -> Self {
                    Self::ChargeCurrentAdc(val)
                }
            }
            impl From<DischargeCurrentAdc> for FieldSetValue {
                fn from(val: DischargeCurrentAdc) -> Self {
                    Self::DischargeCurrentAdc(val)
                }
            }
            impl From<ApsVoltageAdc> for FieldSetValue {
                fn from(val: ApsVoltageAdc) -> Self {
                    Self::ApsVoltageAdc(val)
                }
            }
            impl From<ChargeCoulombCounter> for FieldSetValue {
                fn from(val: ChargeCoulombCounter) -> Self {
                    Self::ChargeCoulombCounter(val)
                }
            }
            impl From<DischargeCoulombCounter> for FieldSetValue {
                fn from(val: DischargeCoulombCounter) -> Self {
                    Self::DischargeCoulombCounter(val)
                }
            }
            impl From<CoulombCounterControl> for FieldSetValue {
                fn from(val: CoulombCounterControl) -> Self {
                    Self::CoulombCounterControl(val)
                }
            }
        }
        pub struct AxpInterface<I2CBus> {
            i2c_bus: I2CBus,
            device_address: u8,
        }
        impl<I2CBus> AxpInterface<I2CBus> {
            pub fn new(i2c_bus: I2CBus, device_address: u8) -> Self {
                Self { i2c_bus, device_address }
            }
        }
        impl<I2CBus, E: core::fmt::Debug> device_driver::AsyncRegisterInterface
        for AxpInterface<I2CBus>
        where
            I2CBus: embedded_hal_async::i2c::I2c<Error = E>,
        {
            type AddressType = u8;
            type Error = AxpError<E>;
            async fn read_register(
                &mut self,
                address: Self::AddressType,
                _size_bits: u32,
                data: &mut [u8],
            ) -> Result<(), Self::Error> {
                self.i2c_bus
                    .write_read(self.device_address, &[address], data)
                    .await
                    .map_err(AxpError::I2c)
            }
            async fn write_register(
                &mut self,
                address: Self::AddressType,
                _size_bits: u32,
                data: &[u8],
            ) -> Result<(), Self::Error> {
                if data.len() > 2 {
                    return Err(AxpError::NotImplemented("Write data too large"));
                }
                let mut buffer = [0u8; 1 + 2];
                buffer[0] = address;
                buffer[1..1 + data.len()].copy_from_slice(data);
                self.i2c_bus
                    .write(self.device_address, &buffer[..1 + data.len()])
                    .await
                    .map_err(AxpError::I2c)
            }
        }
        pub struct Axp192<I2CImpl> {
            ll: Device<I2CImpl>,
        }
        impl<I2CBus, E: core::fmt::Debug> Axp192<AxpInterface<I2CBus>>
        where
            I2CBus: embedded_hal_async::i2c::I2c<Error = E>,
            AxpInterface<
                I2CBus,
            >: device_driver::AsyncRegisterInterface<
                Error = AxpError<E>,
                AddressType = u8,
            >,
        {
            pub fn new(i2c: I2CBus) -> Self {
                Self {
                    ll: Device::new(AxpInterface::new(i2c, 0x34)),
                }
            }
        }
        impl<I2CImpl, I2CBusErr> Axp192<I2CImpl>
        where
            I2CImpl: device_driver::RegisterInterface<
                    AddressType = u8,
                    Error = AxpError<I2CBusErr>,
                >
                + device_driver::AsyncRegisterInterface<
                    AddressType = u8,
                    Error = AxpError<I2CBusErr>,
                >,
            I2CBusErr: core::fmt::Debug,
        {
            pub async fn set_output_enable_dcdc(
                &mut self,
                dc: DcId,
                enable: bool,
            ) -> Result<(), AxpError<I2CBusErr>> {
                let mut op = self.ll.dcdc_13_ldo_23_control();
                op.modify(|r| match dc {
                        DcId::Dcdc1 => r.set_dcdc_1_enable(enable),
                        DcId::Dcdc3 => r.set_dcdc_3_enable(enable),
                    })
                    .await?;
                Ok(())
            }
            pub async fn set_dcdc_voltage(
                &mut self,
                dc: DcId,
                voltage_mv: u16,
            ) -> Result<(), AxpError<I2CBusErr>> {
                if !(700..=3500).contains(&voltage_mv) {
                    return Err(AxpError::InvalidVoltage(voltage_mv));
                }
                let setting = ((voltage_mv - 700) / 25) as u8 & 0x7F;
                match dc {
                    DcId::Dcdc1 => {
                        let mut op = self.ll.dcdc_1_voltage();
                        { op.modify_async(|r| r.set_setting(setting)).await? }
                    }
                    DcId::Dcdc3 => {
                        let mut op = self.ll.dcdc_3_voltage();
                        { op.modify_async(|r| r.set_setting(setting)).await? }
                    }
                }
                Ok(())
            }
            pub async fn is_charging(&mut self) -> Result<bool, AxpError<I2CBusErr>> {
                let fieldset = self.ll.power_status().read().await?;
                Ok(fieldset.battery_current_direction())
            }
            pub async fn get_battery_voltage_mv(
                &mut self,
            ) -> Result<f32, AxpError<I2CBusErr>> {
                let fieldset = self.ll.battery_voltage_adc().read().await?;
                Ok((fieldset.raw() >> 4) as f32 * 1.1)
            }
            pub async fn set_output_enable_ldo(
                &mut self,
                ldo: LdoId,
                enable: bool,
            ) -> Result<(), AxpError<I2CBusErr>> {
                let mut op = self.ll.dcdc_13_ldo_23_control();
                op.modify(|r| match ldo {
                        LdoId::Ldo2 => r.set_ldo_2_enable(enable),
                        LdoId::Ldo3 => r.set_ldo_3_enable(enable),
                    })
                    .await?;
                Ok(())
            }
            pub async fn set_ldo_voltage(
                &mut self,
                ldo: LdoId,
                voltage_mv: u16,
            ) -> Result<(), AxpError<I2CBusErr>> {
                if !(1800..=3300).contains(&voltage_mv) {
                    return Err(AxpError::InvalidVoltage(voltage_mv));
                }
                let setting = ((voltage_mv - 1800) / 100) as u8 & 0x0F;
                let mut op = self.ll.ldo_23_voltage();
                op.modify(|r| match ldo {
                        LdoId::Ldo2 => r.set_ldo_2_setting(setting),
                        LdoId::Ldo3 => r.set_ldo_3_setting(setting),
                    })
                    .await?;
                Ok(())
            }
            pub async fn set_charge_current_ma(
                &mut self,
                current_ma: u16,
            ) -> Result<(), AxpError<I2CBusErr>> {
                let current_bits = match current_ma {
                    0..=100 => 0b0000,
                    101..=190 => 0b0001,
                    191..=280 => 0b0010,
                    281..=370 => 0b0011,
                    371..=460 => 0b0100,
                    461..=550 => 0b0101,
                    551..=640 => 0b0110,
                    641..=780 => 0b0111,
                    _ => return Err(AxpError::InvalidCurrent(current_ma)),
                };
                let mut op = self.ll.charge_control_1();
                op.modify(|r| r.set_charge_current_setting(current_bits)).await?;
                Ok(())
            }
            pub async fn get_acin_voltage_mv(
                &mut self,
            ) -> Result<f32, AxpError<I2CBusErr>> {
                let fieldset = self.ll.acin_voltage_adc().read().await?;
                Ok((fieldset.raw() >> 4) as f32 * 1.7)
            }
            pub async fn get_internal_temperature_c(
                &mut self,
            ) -> Result<f32, AxpError<I2CBusErr>> {
                let fieldset = self.ll.internal_temperature_adc().read().await?;
                Ok(((fieldset.raw() >> 4) as f32 * 0.1) - 144.7)
            }
            pub async fn set_gpio_mode(
                &mut self,
                pin: GpioPin,
                mode: GpioMode,
            ) -> Result<(), AxpError<I2CBusErr>> {
                let mode_val = mode as u8;
                let op = match pin {
                    GpioPin::Gpio0 => self.ll.gpio_0_control(),
                    GpioPin::Gpio1 => self.ll.gpio_1_control(),
                    GpioPin::Gpio2 => self.ll.gpio_2_control(),
                };
                op.modify(|r| r.set_mode(mode_val)).await?;
                Ok(())
            }
            pub async fn set_gpio_output_level(
                &mut self,
                pin: GpioPin,
                level_high: bool,
            ) -> Result<(), AxpError<I2CBusErr>> {
                let mut op = self.ll.gpio_20_signal_status();
                op.modify(|r| match pin {
                        GpioPin::Gpio0 => r.set_gpio_0_out_level(level_high),
                        GpioPin::Gpio1 => r.set_gpio_1_out_level(level_high),
                        GpioPin::Gpio2 => r.set_gpio_2_out_level(level_high),
                    })
                    .await?;
                Ok(())
            }
            pub async fn set_pek_settings(
                &mut self,
                boot_time: PekBootTime,
                long_press: PekLongPressTime,
                auto_shutdown_by_pwrok_en: bool,
                pwrok_signal_delay_64ms: bool,
                shutdown_duration: PekShutdownDuration,
            ) -> Result<(), AxpError<I2CBusErr>> {
                let mut op = self.ll.pek_settings();
                let pwrok_delay_val_for_reg = if pwrok_signal_delay_64ms {
                    1
                } else {
                    0
                };
                op.write(|w| {
                        w.set_boot_time_setting(boot_time as u8);
                        w.set_long_press_time_setting(long_press as u8);
                        w.set_auto_shutdown_by_pwrok_en(auto_shutdown_by_pwrok_en);
                        w.set_pwrok_signal_delay(pwrok_delay_val_for_reg);
                        w.set_shutdown_duration_setting(shutdown_duration as u8);
                    })
                    .await?;
                Ok(())
            }
            pub async fn set_led_enable(
                &mut self,
                enable: bool,
            ) -> Result<(), AxpError<I2CBusErr>> {
                self.set_gpio_output_level(GpioPin::Gpio1, !enable).await
            }
        }
    }
    pub use driver_core::*;
}
pub use asynchronous::Axp192 as Axp192Async;
